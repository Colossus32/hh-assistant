# ĞŸĞ°Ñ‚Ñ‚ĞµÑ€Ğ½Ñ‹ ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²ĞµĞ½Ğ½Ğ¾Ğ³Ğ¾ ĞºĞ¾Ğ´Ğ° Ğ´Ğ»Ñ ÑĞ¾Ğ±ĞµÑĞµĞ´Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğ¹

**Java/Kotlin Backend Developer | Middle/Senior**

---

## ğŸ“‹ Ğ¡Ğ¾Ğ´ĞµÑ€Ğ¶Ğ°Ğ½Ğ¸Ğµ

- [SOLID Ğ¿Ñ€Ğ¸Ğ½Ñ†Ğ¸Ğ¿Ñ‹](#solid-Ğ¿Ñ€Ğ¸Ğ½Ñ†Ğ¸Ğ¿Ñ‹) (ĞšĞµĞ¹ÑÑ‹ 1-8)
- [Clean Code Ğ¿Ñ€Ğ°ĞºÑ‚Ğ¸ĞºĞ¸](#clean-code-Ğ¿Ñ€Ğ°ĞºÑ‚Ğ¸ĞºĞ¸) (ĞšĞµĞ¹ÑÑ‹ 9-16)
- [Ğ ĞµÑ„Ğ°ĞºÑ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³](#Ñ€ĞµÑ„Ğ°ĞºÑ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³) (ĞšĞµĞ¹ÑÑ‹ 17-24)
- [Ğ¢Ğ¸Ğ¿Ğ¸Ñ‡Ğ½Ñ‹Ğµ Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼Ñ‹ Ğ¸ Ğ°Ğ½Ñ‚Ğ¸Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½Ñ‹](#Ñ‚Ğ¸Ğ¿Ğ¸Ñ‡Ğ½Ñ‹Ğµ-Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼Ñ‹-Ğ¸-Ğ°Ğ½Ñ‚Ğ¸Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½Ñ‹) (ĞšĞµĞ¹ÑÑ‹ 25-35)

---

## SOLID Ğ¿Ñ€Ğ¸Ğ½Ñ†Ğ¸Ğ¿Ñ‹

### ĞšĞ•Ğ™Ğ¡ #1 | Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ: Middle
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
**Ğ’ĞĞŸĞ ĞĞ¡:**
Ğ£ Ğ²Ğ°Ñ ĞµÑÑ‚ÑŒ ÑĞµÑ€Ğ²Ğ¸Ñ `OrderService`, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¹ ÑĞ¾Ğ·Ğ´Ğ°ĞµÑ‚ Ğ·Ğ°ĞºĞ°Ğ·, Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµÑ‚ email, Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ÑĞµÑ‚ 
ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºÑƒ Ğ¸ Ğ»Ğ¾Ğ³Ğ¸Ñ€ÑƒĞµÑ‚ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ. Code reviewer Ğ³Ğ¾Ğ²Ğ¾Ñ€Ğ¸Ñ‚, Ñ‡Ñ‚Ğ¾ ÑÑ‚Ğ¾ Ğ½Ğ°Ñ€ÑƒÑˆĞ°ĞµÑ‚ SRP 
(Single Responsibility Principle). ĞšĞ°Ğº Ğ¸ÑĞ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ?

**ĞĞ¢Ğ’Ğ•Ğ¢:**
ĞšĞ»Ğ°ÑÑ Ğ¸Ğ¼ĞµĞµÑ‚ **4 Ğ¿Ñ€Ğ¸Ñ‡Ğ¸Ğ½Ñ‹ Ğ´Ğ»Ñ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ**:
1. Ğ˜Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğµ Ğ±Ğ¸Ğ·Ğ½ĞµÑ-Ğ»Ğ¾Ğ³Ğ¸ĞºĞ¸ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ·Ğ°ĞºĞ°Ğ·Ğ°
2. Ğ˜Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğµ ÑĞ¿Ğ¾ÑĞ¾Ğ±Ğ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ email
3. Ğ˜Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğµ Ğ»Ğ¾Ğ³Ğ¸ĞºĞ¸ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ¸
4. Ğ˜Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğµ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ° Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ

Ğ ĞµÑˆĞµĞ½Ğ¸Ğµ: Ñ€Ğ°Ğ·Ğ´ĞµĞ»Ğ¸Ñ‚ÑŒ Ğ½Ğ° Ğ¾Ñ‚Ğ´ĞµĞ»ÑŒĞ½Ñ‹Ğµ ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ñ‹, ĞºĞ°Ğ¶Ğ´Ñ‹Ğ¹ Ñ Ğ¾Ğ´Ğ½Ğ¾Ğ¹ Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²ĞµĞ½Ğ½Ğ¾ÑÑ‚ÑŒÑ.

**ĞŸĞĞ§Ğ•ĞœĞ£ Ğ­Ğ¢Ğ Ğ’ĞĞ–ĞĞ:**
- Ğ£Ğ¿Ñ€Ğ¾Ñ‰Ğ°ĞµÑ‚ Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ (Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¼Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ ĞºĞ°Ğ¶Ğ´Ñ‹Ğ¹ ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚ Ğ¾Ñ‚Ğ´ĞµĞ»ÑŒĞ½Ğ¾)
- ĞĞ±Ğ»ĞµĞ³Ñ‡Ğ°ĞµÑ‚ Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶ĞºÑƒ (Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ Ğ² email Ğ½Ğµ Ğ²Ğ»Ğ¸ÑÑÑ‚ Ğ½Ğ° Ğ»Ğ¾Ğ³Ğ¸ĞºÑƒ Ğ·Ğ°ĞºĞ°Ğ·Ğ°)
- ĞŸĞ¾Ğ²Ñ‹ÑˆĞ°ĞµÑ‚ Ğ¿ĞµÑ€ĞµĞ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼Ğ¾ÑÑ‚ÑŒ (StatisticsService Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ² Ğ´Ñ€ÑƒĞ³Ğ¸Ñ… Ğ¼ĞµÑÑ‚Ğ°Ñ…)

**ĞŸĞ Ğ˜ĞœĞ•Ğ  ĞšĞĞ”Ğ:**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```kotlin
// ĞŸĞ›ĞĞ¥Ğ: Ğ¾Ğ´Ğ¸Ğ½ ĞºĞ»Ğ°ÑÑ Ğ´ĞµĞ»Ğ°ĞµÑ‚ Ğ²ÑÑ‘
@Service
class OrderServiceBad(
    private val orderRepository: OrderRepository,
    private val emailClient: EmailClient,
    private val statisticsRepository: StatisticsRepository
) {
    fun createOrder(orderDto: OrderDto): Order {
        // 1. Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ·Ğ°ĞºĞ°Ğ·Ğ°
        val order = Order(
            userId = orderDto.userId,
            items = orderDto.items,
            total = orderDto.items.sumOf { it.price * it.quantity }
        )
        val savedOrder = orderRepository.save(order)
        
        // 2. ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ° email
        emailClient.send(
            to = orderDto.userEmail,
            subject = "Ğ—Ğ°ĞºĞ°Ğ· ÑĞ¾Ğ·Ğ´Ğ°Ğ½",
            body = "Ğ’Ğ°Ñˆ Ğ·Ğ°ĞºĞ°Ğ· #${savedOrder.id} ÑĞ¾Ğ·Ğ´Ğ°Ğ½"
        )
        
        // 3. ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ¸
        val stats = statisticsRepository.findByDate(LocalDate.now())
            ?: Statistics(date = LocalDate.now())
        stats.ordersCount += 1
        stats.totalRevenue += savedOrder.total
        statisticsRepository.save(stats)
        
        // 4. Ğ›Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ
        println("[${LocalDateTime.now()}] Order created: ${savedOrder.id}")
        
        return savedOrder
    }
}

// Ğ¥ĞĞ ĞĞ¨Ğ: Ñ€Ğ°Ğ·Ğ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²ĞµĞ½Ğ½Ğ¾ÑÑ‚ĞµĞ¹
@Service
class OrderService(
    private val orderRepository: OrderRepository,
    private val notificationService: NotificationService,
    private val statisticsService: StatisticsService
) {
    private val logger = LoggerFactory.getLogger(javaClass)
    
    @Transactional
    fun createOrder(orderDto: OrderDto): Order {
        // Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ·Ğ°ĞºĞ°Ğ·Ğ°
        val order = Order(
            userId = orderDto.userId,
            items = orderDto.items,
            total = calculateTotal(orderDto.items)
        )
        val savedOrder = orderRepository.save(order)
        
        // Ğ”ĞµĞ»ĞµĞ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ´Ñ€ÑƒĞ³Ğ¸Ğ¼ ÑĞµÑ€Ğ²Ğ¸ÑĞ°Ğ¼
        notificationService.sendOrderCreated(savedOrder, orderDto.userEmail)
        statisticsService.recordOrderCreated(savedOrder)
        logger.info("Order created: orderId=${savedOrder.id}, userId=${orderDto.userId}")
        
        return savedOrder
    }
    
    private fun calculateTotal(items: List<OrderItemDto>): BigDecimal {
        return items.sumOf { it.price * it.quantity.toBigDecimal() }
    }
}

@Service
class NotificationService(
    private val emailClient: EmailClient
) {
    fun sendOrderCreated(order: Order, userEmail: String) {
        emailClient.send(
            to = userEmail,
            subject = "Ğ—Ğ°ĞºĞ°Ğ· ÑĞ¾Ğ·Ğ´Ğ°Ğ½",
            body = buildOrderEmailBody(order)
        )
    }
    
    private fun buildOrderEmailBody(order: Order): String {
        return """
            Ğ’Ğ°Ñˆ Ğ·Ğ°ĞºĞ°Ğ· #${order.id} ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ ÑĞ¾Ğ·Ğ´Ğ°Ğ½!
            Ğ¡ÑƒĞ¼Ğ¼Ğ°: ${order.total} Ñ€ÑƒĞ±.
        """.trimIndent()
    }
}

@Service
class StatisticsService(
    private val statisticsRepository: StatisticsRepository
) {
    @Transactional
    fun recordOrderCreated(order: Order) {
        val date = LocalDate.now()
        val stats = statisticsRepository.findByDate(date)
            ?: Statistics(date = date, ordersCount = 0, totalRevenue = BigDecimal.ZERO)
        
        stats.ordersCount += 1
        stats.totalRevenue += order.total
        statisticsRepository.save(stats)
    }
}

// Ğ¢Ğ•Ğ¡Ğ¢: Ñ‚ĞµĞ¿ĞµÑ€ÑŒ Ğ»ĞµĞ³ĞºĞ¾ Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ ĞºĞ°Ğ¶Ğ´Ñ‹Ğ¹ ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚
@Test
fun `should create order without sending notifications`() {
    val notificationService = mockk<NotificationService>(relaxed = true)
    val statisticsService = mockk<StatisticsService>(relaxed = true)
    
    val service = OrderService(orderRepository, notificationService, statisticsService)
    val order = service.createOrder(testOrderDto)
    
    // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ·Ğ°ĞºĞ°Ğ·Ğ°, Ğ½Ğµ Ğ·Ğ°Ğ±Ğ¾Ñ‚ÑÑÑŒ Ğ¾Ğ± email
    assertNotNull(order.id)
    verify { notificationService.sendOrderCreated(any(), any()) }
}
```
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

### ĞšĞ•Ğ™Ğ¡ #2 | Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ: Middle
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
**Ğ’ĞĞŸĞ ĞĞ¡:**
Ğ£ Ğ²Ğ°Ñ ĞµÑÑ‚ÑŒ Ğ¼ĞµÑ‚Ğ¾Ğ´ `processPayment()`, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¹ Ğ¿Ñ€Ğ¸Ğ½Ğ¸Ğ¼Ğ°ĞµÑ‚ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€ `paymentType: String`. 
Ğ’Ğ½ÑƒÑ‚Ñ€Ğ¸ Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ° Ğ±Ğ¾Ğ»ÑŒÑˆĞ¾Ğ¹ `when/switch` Ğ´Ğ»Ñ Ñ€Ğ°Ğ·Ğ½Ñ‹Ñ… Ñ‚Ğ¸Ğ¿Ğ¾Ğ². Code reviewer Ğ³Ğ¾Ğ²Ğ¾Ñ€Ğ¸Ñ‚, Ñ‡Ñ‚Ğ¾ ÑÑ‚Ğ¾ 
Ğ½Ğ°Ñ€ÑƒÑˆĞ°ĞµÑ‚ OCP (Open/Closed Principle). ĞŸĞ¾Ñ‡ĞµĞ¼Ñƒ Ğ¸ ĞºĞ°Ğº Ğ¸ÑĞ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ?

**ĞĞ¢Ğ’Ğ•Ğ¢:**
ĞŸÑ€Ğ¸ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğ¸ Ğ½Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ñ‚Ğ¸Ğ¿Ğ° Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ñ‹ Ğ½ÑƒĞ¶Ğ½Ğ¾ **Ğ¸Ğ·Ğ¼ĞµĞ½ÑÑ‚ÑŒ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰Ğ¸Ğ¹ ĞºĞ¾Ğ´** (Ğ¼Ğ¾Ğ´Ğ¸Ñ„Ğ¸Ñ†Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ `when`), 
Ğ° Ğ½Ğµ Ñ€Ğ°ÑÑˆĞ¸Ñ€ÑÑ‚ÑŒ. OCP Ñ‚Ñ€ĞµĞ±ÑƒĞµÑ‚: **Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚ Ğ´Ğ»Ñ Ñ€Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ¸Ñ, Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚ Ğ´Ğ»Ñ Ğ¼Ğ¾Ğ´Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸**.

Ğ ĞµÑˆĞµĞ½Ğ¸Ğµ: Strategy pattern â€” ÑĞ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ Ğ¸ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ Ğ´Ğ»Ñ ĞºĞ°Ğ¶Ğ´Ğ¾Ğ³Ğ¾ Ñ‚Ğ¸Ğ¿Ğ°.

**ĞŸĞĞ§Ğ•ĞœĞ£ Ğ­Ğ¢Ğ Ğ’ĞĞ–ĞĞ:**
- ĞĞ¾Ğ²Ñ‹Ğµ Ñ‚Ğ¸Ğ¿Ñ‹ Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ñ‹ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑÑÑ‚ÑÑ Ğ±ĞµĞ· Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰ĞµĞ³Ğ¾ ĞºĞ¾Ğ´Ğ°
- ĞšĞ°Ğ¶Ğ´Ğ°Ñ ÑÑ‚Ñ€Ğ°Ñ‚ĞµĞ³Ğ¸Ñ Ñ‚ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ÑÑ Ğ½ĞµĞ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾
- Ğ£Ğ¼ĞµĞ½ÑŒÑˆĞ°ĞµÑ‚ÑÑ Ñ€Ğ¸ÑĞº Ñ€ĞµĞ³Ñ€ĞµÑÑĞ¸Ğ¸ Ğ¿Ñ€Ğ¸ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğ¸ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¾Ğ½Ğ°Ğ»Ğ°

**ĞŸĞ Ğ˜ĞœĞ•Ğ  ĞšĞĞ”Ğ:**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```kotlin
// ĞŸĞ›ĞĞ¥Ğ: Ğ½Ğ°Ñ€ÑƒÑˆĞµĞ½Ğ¸Ğµ OCP â€” Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ¼Ğ¾Ğ´Ğ¸Ñ„Ğ¸Ñ†Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¼ĞµÑ‚Ğ¾Ğ´ Ğ´Ğ»Ñ ĞºĞ°Ğ¶Ğ´Ğ¾Ğ³Ğ¾ Ğ½Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ñ‚Ğ¸Ğ¿Ğ°
@Service
class PaymentServiceBad {
    
    fun processPayment(amount: BigDecimal, paymentType: String, details: Map<String, Any>): PaymentResult {
        return when (paymentType) {
            "CARD" -> {
                val cardNumber = details["cardNumber"] as String
                val cvv = details["cvv"] as String
                // Ğ›Ğ¾Ğ³Ğ¸ĞºĞ° Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ñ‹ ĞºĞ°Ñ€Ñ‚Ğ¾Ğ¹
                PaymentResult(success = true, transactionId = "CARD-${UUID.randomUUID()}")
            }
            "PAYPAL" -> {
                val email = details["email"] as String
                // Ğ›Ğ¾Ğ³Ğ¸ĞºĞ° PayPal
                PaymentResult(success = true, transactionId = "PP-${UUID.randomUUID()}")
            }
            "CRYPTO" -> {
                val walletAddress = details["walletAddress"] as String
                // Ğ›Ğ¾Ğ³Ğ¸ĞºĞ° ĞºÑ€Ğ¸Ğ¿Ñ‚Ğ¾Ğ²Ğ°Ğ»ÑÑ‚Ñ‹
                PaymentResult(success = true, transactionId = "CRYPTO-${UUID.randomUUID()}")
            }
            // ĞŸÑ€Ğ¸ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğ¸ Ğ½Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ñ‚Ğ¸Ğ¿Ğ° Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ˜Ğ—ĞœĞ•ĞĞ˜Ğ¢Ğ¬ ÑÑ‚Ğ¾Ñ‚ Ğ¼ĞµÑ‚Ğ¾Ğ´!
            else -> throw IllegalArgumentException("Unknown payment type: $paymentType")
        }
    }
}

// Ğ¥ĞĞ ĞĞ¨Ğ: ÑĞ¾Ğ±Ğ»ÑĞ´ĞµĞ½Ğ¸Ğµ OCP Ñ‡ĞµÑ€ĞµĞ· Strategy pattern
interface PaymentStrategy {
    fun process(amount: BigDecimal, details: Map<String, Any>): PaymentResult
    fun supports(paymentType: String): Boolean
}

@Component
class CardPaymentStrategy : PaymentStrategy {
    override fun process(amount: BigDecimal, details: Map<String, Any>): PaymentResult {
        val cardNumber = details["cardNumber"] as String
        val cvv = details["cvv"] as String
        
        // Ğ›Ğ¾Ğ³Ğ¸ĞºĞ° Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ñ‹ ĞºĞ°Ñ€Ñ‚Ğ¾Ğ¹
        // ...
        
        return PaymentResult(
            success = true,
            transactionId = "CARD-${UUID.randomUUID()}",
            amount = amount
        )
    }
    
    override fun supports(paymentType: String): Boolean = paymentType == "CARD"
}

@Component
class PayPalPaymentStrategy : PaymentStrategy {
    override fun process(amount: BigDecimal, details: Map<String, Any>): PaymentResult {
        val email = details["email"] as String
        
        // Ğ›Ğ¾Ğ³Ğ¸ĞºĞ° PayPal
        // ...
        
        return PaymentResult(
            success = true,
            transactionId = "PP-${UUID.randomUUID()}",
            amount = amount
        )
    }
    
    override fun supports(paymentType: String): Boolean = paymentType == "PAYPAL"
}

// ĞĞ¾Ğ²Ñ‹Ğ¹ Ñ‚Ğ¸Ğ¿ Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ñ‹ â€” Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ ĞºĞ»Ğ°ÑÑ, ĞĞ• Ğ˜Ğ—ĞœĞ•ĞĞ¯Ğ¯ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰Ğ¸Ğ¹ ĞºĞ¾Ğ´
@Component
class CryptoPaymentStrategy : PaymentStrategy {
    override fun process(amount: BigDecimal, details: Map<String, Any>): PaymentResult {
        val walletAddress = details["walletAddress"] as String
        
        // Ğ›Ğ¾Ğ³Ğ¸ĞºĞ° ĞºÑ€Ğ¸Ğ¿Ñ‚Ğ¾Ğ²Ğ°Ğ»ÑÑ‚Ñ‹
        // ...
        
        return PaymentResult(
            success = true,
            transactionId = "CRYPTO-${UUID.randomUUID()}",
            amount = amount
        )
    }
    
    override fun supports(paymentType: String): Boolean = paymentType == "CRYPTO"
}

@Service
class PaymentService(
    private val strategies: List<PaymentStrategy> // Spring Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ Ğ¸Ğ½Ğ¶ĞµĞºÑ‚Ğ¸Ñ‚ Ğ²ÑĞµ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸
) {
    
    fun processPayment(amount: BigDecimal, paymentType: String, details: Map<String, Any>): PaymentResult {
        val strategy = strategies.firstOrNull { it.supports(paymentType) }
            ?: throw IllegalArgumentException("Unsupported payment type: $paymentType")
        
        return strategy.process(amount, details)
    }
}

// Ğ¢Ğ•Ğ¡Ğ¢: Ğ»ĞµĞ³ĞºĞ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑÑ‚ÑŒ Ğ¸ Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ½Ğ¾Ğ²Ñ‹Ğµ ÑÑ‚Ñ€Ğ°Ñ‚ĞµĞ³Ğ¸Ğ¸
@Test
fun `should support new payment type without modifying existing code`() {
    // Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ Ğ½Ğ¾Ğ²ÑƒÑ ÑÑ‚Ñ€Ğ°Ñ‚ĞµĞ³Ğ¸Ñ Ğ´Ğ»Ñ Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
    val applePayStrategy = object : PaymentStrategy {
        override fun process(amount: BigDecimal, details: Map<String, Any>) =
            PaymentResult(true, "APPLE-123", amount)
        override fun supports(paymentType: String) = paymentType == "APPLE_PAY"
    }
    
    val service = PaymentService(listOf(applePayStrategy))
    val result = service.processPayment(
        amount = BigDecimal("100.00"),
        paymentType = "APPLE_PAY",
        details = mapOf("deviceId" to "iPhone-123")
    )
    
    assertTrue(result.success)
    assertTrue(result.transactionId.startsWith("APPLE"))
}
```
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

### ĞšĞ•Ğ™Ğ¡ #3 | Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ: Senior
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
**Ğ’ĞĞŸĞ ĞĞ¡:**
Ğ£ Ğ²Ğ°Ñ ĞµÑÑ‚ÑŒ Ğ¸ĞµÑ€Ğ°Ñ€Ñ…Ğ¸Ñ: `Bird` â†’ `Penguin`. ĞšĞ»Ğ°ÑÑ `Bird` Ğ¸Ğ¼ĞµĞµÑ‚ Ğ¼ĞµÑ‚Ğ¾Ğ´ `fly()`, Ğ½Ğ¾ 
Ğ¿Ğ¸Ğ½Ğ³Ğ²Ğ¸Ğ½Ñ‹ Ğ½Ğµ Ğ»ĞµÑ‚Ğ°ÑÑ‚. Ğ’Ñ‹ Ğ¿ĞµÑ€ĞµĞ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµÑ‚Ğµ `fly()` Ğ² `Penguin` Ğ¸ Ğ±Ñ€Ğ¾ÑĞ°ĞµÑ‚Ğµ Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ. 
Code reviewer Ğ³Ğ¾Ğ²Ğ¾Ñ€Ğ¸Ñ‚, Ñ‡Ñ‚Ğ¾ ÑÑ‚Ğ¾ Ğ½Ğ°Ñ€ÑƒÑˆĞ°ĞµÑ‚ LSP (Liskov Substitution Principle). ĞĞ±ÑŠÑÑĞ½Ğ¸Ñ‚Ğµ 
Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼Ñƒ Ğ¸ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶Ğ¸Ñ‚Ğµ Ñ€ĞµÑˆĞµĞ½Ğ¸Ğµ.

**ĞĞ¢Ğ’Ğ•Ğ¢:**
LSP Ñ‚Ñ€ĞµĞ±ÑƒĞµÑ‚: Ğ¿Ğ¾Ğ´Ñ‚Ğ¸Ğ¿ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ¿Ğ¾Ğ»Ğ½Ğ¾ÑÑ‚ÑŒÑ Ğ·Ğ°Ğ¼ĞµĞ½ÑÑ‚ÑŒ Ğ±Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğ¹ Ñ‚Ğ¸Ğ¿ **Ğ±ĞµĞ· Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ Ğ¿Ğ¾Ğ²ĞµĞ´ĞµĞ½Ğ¸Ñ**. 
Ğ•ÑĞ»Ğ¸ ĞºĞ¾Ğ´ Ğ¾Ğ¶Ğ¸Ğ´Ğ°ĞµÑ‚, Ñ‡Ñ‚Ğ¾ Ğ»ÑĞ±Ğ°Ñ `Bird` Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ»ĞµÑ‚Ğ°Ñ‚ÑŒ, Ğ° `Penguin` Ğ±Ñ€Ğ¾ÑĞ°ĞµÑ‚ Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ â€” 
ÑÑ‚Ğ¾ Ğ½Ğ°Ñ€ÑƒÑˆĞµĞ½Ğ¸Ğµ ĞºĞ¾Ğ½Ñ‚Ñ€Ğ°ĞºÑ‚Ğ°.

ĞŸÑ€Ğ¾Ğ±Ğ»ĞµĞ¼Ğ°: ĞºĞ»Ğ¸ĞµĞ½Ñ‚ÑĞºĞ¸Ğ¹ ĞºĞ¾Ğ´ Ğ½Ğµ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ `Penguin` Ğ²Ğ¼ĞµÑÑ‚Ğ¾ `Bird`.

**ĞŸĞĞ§Ğ•ĞœĞ£ Ğ­Ğ¢Ğ Ğ’ĞĞ–ĞĞ:**
- ĞŸÑ€ĞµĞ´ÑĞºĞ°Ğ·ÑƒĞµĞ¼Ğ¾ÑÑ‚ÑŒ: ĞºĞ¾Ğ´ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ñ‚ÑŒ Ğ¾Ğ´Ğ¸Ğ½Ğ°ĞºĞ¾Ğ²Ğ¾ Ğ´Ğ»Ñ Ğ²ÑĞµÑ… Ğ¿Ğ¾Ğ´Ñ‚Ğ¸Ğ¿Ğ¾Ğ²
- Ğ‘ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚ÑŒ: Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ Ğ² runtime â€” Ğ¿Ñ€Ğ¸Ğ·Ğ½Ğ°Ğº Ğ¿Ğ»Ğ¾Ñ…Ğ¾Ğ³Ğ¾ Ğ´Ğ¸Ğ·Ğ°Ğ¹Ğ½Ğ°
- ĞŸĞ¾Ğ»Ğ¸Ğ¼Ğ¾Ñ€Ñ„Ğ¸Ğ·Ğ¼: Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¿Ğ¾Ğ´Ñ‚Ğ¸Ğ¿Ñ‹ Ğ±ĞµĞ· Ğ·Ğ½Ğ°Ğ½Ğ¸Ñ Ğ¸Ñ… Ğ¾ÑĞ¾Ğ±ĞµĞ½Ğ½Ğ¾ÑÑ‚ĞµĞ¹

**ĞŸĞ Ğ˜ĞœĞ•Ğ  ĞšĞĞ”Ğ:**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```kotlin
// ĞŸĞ›ĞĞ¥Ğ: Ğ½Ğ°Ñ€ÑƒÑˆĞµĞ½Ğ¸Ğµ LSP
abstract class Bird {
    abstract fun fly(): String
}

class Sparrow : Bird() {
    override fun fly(): String = "Sparrow is flying"
}

class Penguin : Bird() {
    override fun fly(): String {
        // ĞĞ°Ñ€ÑƒÑˆĞµĞ½Ğ¸Ğµ LSP: Ğ±Ñ€Ğ¾ÑĞ°ĞµĞ¼ Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ Ğ²Ğ¼ĞµÑÑ‚Ğ¾ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ ĞºĞ¾Ğ½Ñ‚Ñ€Ğ°ĞºÑ‚Ğ°
        throw UnsupportedOperationException("Penguins can't fly!")
    }
}

fun makeBirdFly(bird: Bird) {
    // ĞĞ¶Ğ¸Ğ´Ğ°ĞµĞ¼, Ñ‡Ñ‚Ğ¾ Ğ»ÑĞ±Ğ°Ñ Bird Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ»ĞµÑ‚Ğ°Ñ‚ÑŒ
    println(bird.fly()) // ĞœĞ¾Ğ¶ĞµÑ‚ ÑƒĞ¿Ğ°ÑÑ‚ÑŒ Ğ´Ğ»Ñ Penguin!
}

// Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ
makeBirdFly(Sparrow()) // OK
makeBirdFly(Penguin()) // EXCEPTION! ĞĞ°Ñ€ÑƒÑˆĞµĞ½Ğ¸Ğµ LSP

// Ğ¥ĞĞ ĞĞ¨Ğ: Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğµ Ñ€Ğ°Ğ·Ğ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ğ½Ğ° Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹ÑÑ‹
interface Bird {
    fun eat(): String
    fun makeSound(): String
}

interface Flyable {
    fun fly(): String
}

interface Swimmable {
    fun swim(): String
}

class Sparrow : Bird, Flyable {
    override fun eat() = "Sparrow is eating seeds"
    override fun makeSound() = "Chirp chirp"
    override fun fly() = "Sparrow is flying high"
}

class Penguin : Bird, Swimmable {
    override fun eat() = "Penguin is eating fish"
    override fun makeSound() = "Squawk"
    override fun swim() = "Penguin is swimming gracefully"
}

class Duck : Bird, Flyable, Swimmable {
    override fun eat() = "Duck is eating bread"
    override fun makeSound() = "Quack"
    override fun fly() = "Duck is flying"
    override fun swim() = "Duck is swimming"
}

// Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ: ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ñ‹ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ÑÑ‚ Ñ Ğ½ÑƒĞ¶Ğ½Ñ‹Ğ¼Ğ¸ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹ÑĞ°Ğ¼Ğ¸
fun makeFly(flyable: Flyable) {
    println(flyable.fly()) // Ğ Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ´Ğ»Ñ Ğ»ĞµÑ‚Ğ°ÑÑ‰Ğ¸Ñ… Ğ¿Ñ‚Ğ¸Ñ†
}

fun makeSwim(swimmable: Swimmable) {
    println(swimmable.swim()) // Ğ Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ´Ğ»Ñ Ğ¿Ğ»Ğ°Ğ²Ğ°ÑÑ‰Ğ¸Ñ… Ğ¿Ñ‚Ğ¸Ñ†
}

// Ğ¢ĞµĞ¿ĞµÑ€ÑŒ ĞºĞ¾Ğ¼Ğ¿Ğ¸Ğ»ÑÑ‚Ğ¾Ñ€ Ğ½Ğµ Ğ¿Ğ¾Ğ·Ğ²Ğ¾Ğ»Ğ¸Ñ‚ Ğ²Ñ‹Ğ·Ğ²Ğ°Ñ‚ÑŒ fly() Ğ´Ğ»Ñ Penguin
makeFly(Sparrow()) // OK
makeFly(Duck())    // OK
// makeFly(Penguin()) // ĞĞ¨Ğ˜Ğ‘ĞšĞ ĞšĞĞœĞŸĞ˜Ğ›Ğ¯Ğ¦Ğ˜Ğ˜ â€” Ñƒ Penguin Ğ½ĞµÑ‚ fly()

makeSwim(Penguin()) // OK
makeSwim(Duck())    // OK
// makeSwim(Sparrow()) // ĞĞ¨Ğ˜Ğ‘ĞšĞ ĞšĞĞœĞŸĞ˜Ğ›Ğ¯Ğ¦Ğ˜Ğ˜ â€” Ñƒ Sparrow Ğ½ĞµÑ‚ swim()

// ĞĞ›Ğ¬Ğ¢Ğ•Ğ ĞĞĞ¢Ğ˜Ğ’ĞĞ«Ğ™ ĞŸĞĞ”Ğ¥ĞĞ”: ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ Ğ²Ğ¼ĞµÑÑ‚Ğ¾ Ğ½Ğ°ÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
data class BirdCharacteristics(
    val canFly: Boolean,
    val canSwim: Boolean,
    val sound: String
)

class BirdWithComposition(
    private val name: String,
    private val characteristics: BirdCharacteristics
) {
    fun fly(): String {
        return if (characteristics.canFly) {
            "$name is flying"
        } else {
            "$name cannot fly"
        }
    }
    
    fun swim(): String {
        return if (characteristics.canSwim) {
            "$name is swimming"
        } else {
            "$name cannot swim"
        }
    }
    
    fun makeSound(): String = characteristics.sound
}

// Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ
val sparrow = BirdWithComposition(
    "Sparrow",
    BirdCharacteristics(canFly = true, canSwim = false, sound = "Chirp")
)

val penguin = BirdWithComposition(
    "Penguin",
    BirdCharacteristics(canFly = false, canSwim = true, sound = "Squawk")
)

println(sparrow.fly())  // "Sparrow is flying"
println(penguin.fly())  // "Penguin cannot fly" â€” Ğ½Ğµ Ğ±Ñ€Ğ¾ÑĞ°ĞµÑ‚ Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ!
```
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

### ĞšĞ•Ğ™Ğ¡ #4 | Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ: Middle
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
**Ğ’ĞĞŸĞ ĞĞ¡:**
Ğ£ Ğ²Ğ°Ñ ĞµÑÑ‚ÑŒ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ `UserRepository` Ñ 15 Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ°Ğ¼Ğ¸ (CRUD, Ğ¿Ğ¾Ğ¸ÑĞº, Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ, 
ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°). Ğ’Ğ°Ğ¼ Ğ½ÑƒĞ¶ĞµĞ½ ĞºĞ»Ğ°ÑÑ `ReadOnlyUserService`, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¹ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¼ĞµÑ‚Ğ¾Ğ´Ñ‹ 
Ñ‡Ñ‚ĞµĞ½Ğ¸Ñ. Code reviewer Ğ³Ğ¾Ğ²Ğ¾Ñ€Ğ¸Ñ‚, Ñ‡Ñ‚Ğ¾ ÑÑ‚Ğ¾ Ğ½Ğ°Ñ€ÑƒÑˆĞ°ĞµÑ‚ ISP (Interface Segregation Principle). 
ĞšĞ°Ğº Ğ¸ÑĞ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ?

**ĞĞ¢Ğ’Ğ•Ğ¢:**
ISP: ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ñ‹ Ğ½Ğµ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ñ‹ Ğ·Ğ°Ğ²Ğ¸ÑĞµÑ‚ÑŒ Ğ¾Ñ‚ Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ¾Ğ², ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ½Ğµ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒÑÑ‚. `ReadOnlyUserService` 
Ğ²Ñ‹Ğ½ÑƒĞ¶Ğ´ĞµĞ½ Ğ·Ğ°Ğ²Ğ¸ÑĞµÑ‚ÑŒ Ğ¾Ñ‚ 15 Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ¾Ğ², Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒÑ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ 3-4.

Ğ ĞµÑˆĞµĞ½Ğ¸Ğµ: Ñ€Ğ°Ğ·Ğ´ĞµĞ»Ğ¸Ñ‚ÑŒ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ Ğ½Ğ° Ğ±Ğ¾Ğ»ĞµĞµ ÑĞ¿ĞµÑ†Ğ¸Ñ„Ğ¸Ñ‡Ğ½Ñ‹Ğµ.

**ĞŸĞĞ§Ğ•ĞœĞ£ Ğ­Ğ¢Ğ Ğ’ĞĞ–ĞĞ:**
- Ğ£Ğ¼ĞµĞ½ÑŒÑˆĞµĞ½Ğ¸Ğµ ÑĞ²ÑĞ·Ğ°Ğ½Ğ½Ğ¾ÑÑ‚Ğ¸: Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ Ğ² write-Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ°Ñ… Ğ½Ğµ Ğ²Ğ»Ğ¸ÑÑÑ‚ Ğ½Ğ° read-only ÑĞµÑ€Ğ²Ğ¸ÑÑ‹
- Ğ£Ğ¿Ñ€Ğ¾Ñ‰ĞµĞ½Ğ¸Ğµ Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ: Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ¼Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼Ñ‹Ğµ Ğ¼ĞµÑ‚Ğ¾Ğ´Ñ‹
- Ğ¯Ğ²Ğ½Ğ¾Ğµ Ñ€Ğ°Ğ·Ğ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²ĞµĞ½Ğ½Ğ¾ÑÑ‚Ğ¸: ÑÑ€Ğ°Ğ·Ñƒ Ğ²Ğ¸Ğ´Ğ½Ğ¾, Ñ‡Ñ‚Ğ¾ ÑĞµÑ€Ğ²Ğ¸Ñ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ñ‡Ğ¸Ñ‚Ğ°ĞµÑ‚ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ

**ĞŸĞ Ğ˜ĞœĞ•Ğ  ĞšĞĞ”Ğ:**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```kotlin
// ĞŸĞ›ĞĞ¥Ğ: Ñ‚Ğ¾Ğ»ÑÑ‚Ñ‹Ğ¹ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ
interface UserRepository {
    // Read operations
    fun findById(id: Long): User?
    fun findAll(): List<User>
    fun findByEmail(email: String): User?
    fun search(criteria: SearchCriteria): List<User>
    fun count(): Long
    
    // Write operations
    fun save(user: User): User
    fun update(user: User): User
    fun delete(id: Long)
    fun deleteAll()
    
    // Batch operations
    fun saveAll(users: List<User>): List<User>
    fun deleteAll(ids: List<Long>)
    
    // Statistics
    fun countByStatus(status: UserStatus): Long
    fun getAverageAge(): Double
    fun getRegistrationStats(): RegistrationStats
}

// ĞĞ°Ñ€ÑƒÑˆĞµĞ½Ğ¸Ğµ ISP: ĞºĞ»Ğ°ÑÑ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ñ‚ Ğ¾Ñ‚ Ğ²ÑĞµÑ… 15 Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ¾Ğ², Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒÑ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ 3
class ReadOnlyUserService(
    private val userRepository: UserRepository // Ğ—Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ÑŒ Ğ¾Ñ‚ Ğ’Ğ¡Ğ•Ğ¥ Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ¾Ğ²!
) {
    fun getUserById(id: Long): UserDto? {
        return userRepository.findById(id)?.toDto()
    }
    
    fun searchUsers(criteria: SearchCriteria): List<UserDto> {
        return userRepository.search(criteria).map { it.toDto() }
    }
    
    // Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ read-Ğ¼ĞµÑ‚Ğ¾Ğ´Ñ‹, Ğ½Ğ¾ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼ Ğ¾Ñ‚ Ğ²ÑĞµÑ…!
}

// Ğ¥ĞĞ ĞĞ¨Ğ: Ñ€Ğ°Ğ·Ğ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹ÑĞ¾Ğ²
interface UserReadRepository {
    fun findById(id: Long): User?
    fun findAll(): List<User>
    fun findByEmail(email: String): User?
    fun search(criteria: SearchCriteria): List<User>
    fun count(): Long
}

interface UserWriteRepository {
    fun save(user: User): User
    fun update(user: User): User
    fun delete(id: Long)
    fun deleteAll()
    fun saveAll(users: List<User>): List<User>
    fun deleteAll(ids: List<Long>)
}

interface UserStatisticsRepository {
    fun countByStatus(status: UserStatus): Long
    fun getAverageAge(): Double
    fun getRegistrationStats(): RegistrationStats
}

// Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ¾Ğ±ÑŠĞµĞ´Ğ¸Ğ½ÑĞµÑ‚ Ğ²ÑĞµ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹ÑÑ‹
@Repository
class UserRepositoryImpl : UserReadRepository, UserWriteRepository, UserStatisticsRepository {
    // Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ²ÑĞµÑ… Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ¾Ğ²
    override fun findById(id: Long): User? = TODO()
    override fun save(user: User): User = TODO()
    override fun countByStatus(status: UserStatus): Long = TODO()
    // ... Ğ¾ÑÑ‚Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ¼ĞµÑ‚Ğ¾Ğ´Ñ‹
}

// Ğ¢ĞµĞ¿ĞµÑ€ÑŒ ĞºĞ°Ğ¶Ğ´Ñ‹Ğ¹ ÑĞµÑ€Ğ²Ğ¸Ñ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ñ‚ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¾Ñ‚ Ğ½ÑƒĞ¶Ğ½Ğ¾Ğ³Ğ¾ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹ÑĞ°
@Service
class ReadOnlyUserService(
    private val userReadRepository: UserReadRepository // Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ read-Ğ¼ĞµÑ‚Ğ¾Ğ´Ñ‹!
) {
    fun getUserById(id: Long): UserDto? {
        return userReadRepository.findById(id)?.toDto()
    }
    
    fun searchUsers(criteria: SearchCriteria): List<UserDto> {
        return userReadRepository.search(criteria).map { it.toDto() }
    }
}

@Service
class UserManagementService(
    private val userReadRepository: UserReadRepository,
    private val userWriteRepository: UserWriteRepository // Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ write-Ğ¼ĞµÑ‚Ğ¾Ğ´Ñ‹!
) {
    fun createUser(userDto: UserDto): UserDto {
        val user = userDto.toEntity()
        val savedUser = userWriteRepository.save(user)
        return savedUser.toDto()
    }
    
    fun updateUser(id: Long, userDto: UserDto): UserDto {
        val existingUser = userReadRepository.findById(id)
            ?: throw NotFoundException("User not found: $id")
        
        val updatedUser = existingUser.copy(
            name = userDto.name,
            email = userDto.email
        )
        
        return userWriteRepository.update(updatedUser).toDto()
    }
}

@Service
class UserAnalyticsService(
    private val userStatisticsRepository: UserStatisticsRepository // Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°!
) {
    fun getUserStatistics(): UserStatisticsDto {
        return UserStatisticsDto(
            totalUsers = userStatisticsRepository.countByStatus(UserStatus.ACTIVE),
            averageAge = userStatisticsRepository.getAverageAge(),
            registrationStats = userStatisticsRepository.getRegistrationStats()
        )
    }
}

// Ğ¢Ğ•Ğ¡Ğ¢: Ğ»ĞµĞ³ĞºĞ¾ Ğ¼Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ½ÑƒĞ¶Ğ½Ñ‹Ğµ Ğ¼ĞµÑ‚Ğ¾Ğ´Ñ‹
@Test
fun `should get user by id`() {
    val userReadRepository = mockk<UserReadRepository>()
    every { userReadRepository.findById(1L) } returns testUser
    
    val service = ReadOnlyUserService(userReadRepository)
    val result = service.getUserById(1L)
    
    assertNotNull(result)
    verify(exactly = 1) { userReadRepository.findById(1L) }
    // ĞĞµ Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ¼Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ write/statistics Ğ¼ĞµÑ‚Ğ¾Ğ´Ñ‹!
}
```
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

### ĞšĞ•Ğ™Ğ¡ #5 | Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ: Senior
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
**Ğ’ĞĞŸĞ ĞĞ¡:**
Ğ£ Ğ²Ğ°Ñ ĞµÑÑ‚ÑŒ `OrderService`, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¹ Ğ½Ğ°Ğ¿Ñ€ÑĞ¼ÑƒÑ ÑĞ¾Ğ·Ğ´Ğ°ĞµÑ‚ ÑĞºĞ·ĞµĞ¼Ğ¿Ğ»ÑÑ€Ñ‹ `EmailSender` Ğ¸ 
`PaymentGateway`. Code reviewer Ğ³Ğ¾Ğ²Ğ¾Ñ€Ğ¸Ñ‚, Ñ‡Ñ‚Ğ¾ ÑÑ‚Ğ¾ Ğ½Ğ°Ñ€ÑƒÑˆĞ°ĞµÑ‚ DIP (Dependency Inversion 
Principle) Ğ¸ Ğ·Ğ°Ñ‚Ñ€ÑƒĞ´Ğ½ÑĞµÑ‚ Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ. ĞšĞ°Ğº Ğ¸ÑĞ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¸ Ğ¿Ğ¾Ñ‡ĞµĞ¼Ñƒ ÑÑ‚Ğ¾ Ğ²Ğ°Ğ¶Ğ½Ğ¾?

**ĞĞ¢Ğ’Ğ•Ğ¢:**
DIP: Ğ¼Ğ¾Ğ´ÑƒĞ»Ğ¸ Ğ²Ñ‹ÑĞ¾ĞºĞ¾Ğ³Ğ¾ ÑƒÑ€Ğ¾Ğ²Ğ½Ñ Ğ½Ğµ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ñ‹ Ğ·Ğ°Ğ²Ğ¸ÑĞµÑ‚ÑŒ Ğ¾Ñ‚ Ğ¼Ğ¾Ğ´ÑƒĞ»ĞµĞ¹ Ğ½Ğ¸Ğ·ĞºĞ¾Ğ³Ğ¾ ÑƒÑ€Ğ¾Ğ²Ğ½Ñ. ĞĞ±Ğ° Ğ´Ğ¾Ğ»Ğ¶Ğ½Ñ‹ 
Ğ·Ğ°Ğ²Ğ¸ÑĞµÑ‚ÑŒ Ğ¾Ñ‚ Ğ°Ğ±ÑÑ‚Ñ€Ğ°ĞºÑ†Ğ¸Ğ¹.

ĞŸÑ€Ğ¾Ğ±Ğ»ĞµĞ¼Ğ°: `OrderService` (high-level) Ğ½Ğ°Ğ¿Ñ€ÑĞ¼ÑƒÑ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ñ‚ Ğ¾Ñ‚ ĞºĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½Ñ‹Ñ… Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¹ 
(low-level), Ğ½ĞµĞ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¿Ğ¾Ğ´Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ¸Ñ… Ğ² Ñ‚ĞµÑÑ‚Ğ°Ñ… Ğ¸Ğ»Ğ¸ Ğ¸Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ.

**ĞŸĞĞ§Ğ•ĞœĞ£ Ğ­Ğ¢Ğ Ğ’ĞĞ–ĞĞ:**
- Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµĞ¼Ğ¾ÑÑ‚ÑŒ: Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¿Ğ¾Ğ´Ğ¼ĞµĞ½ÑÑ‚ÑŒ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ Ğ¼Ğ¾ĞºĞ°Ğ¼Ğ¸
- Ğ“Ğ¸Ğ±ĞºĞ¾ÑÑ‚ÑŒ: Ğ»ĞµĞ³ĞºĞ¾ Ğ¼ĞµĞ½ÑÑ‚ÑŒ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ (SMTP â†’ SendGrid, Stripe â†’ PayPal)
- Ğ˜Ğ½Ğ²ĞµÑ€ÑĞ¸Ñ ĞºĞ¾Ğ½Ñ‚Ñ€Ğ¾Ğ»Ñ: Ñ„Ñ€ĞµĞ¹Ğ¼Ğ²Ğ¾Ñ€Ğº ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ÑĞµÑ‚ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸ĞµĞ¼ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ĞµĞ¹

**ĞŸĞ Ğ˜ĞœĞ•Ğ  ĞšĞĞ”Ğ:**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```kotlin
// ĞŸĞ›ĞĞ¥Ğ: Ğ½Ğ°Ñ€ÑƒÑˆĞµĞ½Ğ¸Ğµ DIP â€” Ğ¶ĞµÑÑ‚ĞºĞ°Ñ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ÑŒ Ğ¾Ñ‚ ĞºĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½Ñ‹Ñ… ĞºĞ»Ğ°ÑÑĞ¾Ğ²
class SmtpEmailSender {
    fun send(to: String, subject: String, body: String) {
        // SMTP Ğ»Ğ¾Ğ³Ğ¸ĞºĞ°
        println("Sending email via SMTP to $to")
    }
}

class StripePaymentGateway {
    fun charge(amount: BigDecimal, cardToken: String): String {
        // Stripe API Ğ»Ğ¾Ğ³Ğ¸ĞºĞ°
        println("Charging $amount via Stripe")
        return "stripe_tx_${UUID.randomUUID()}"
    }
}

class OrderServiceBad {
    // Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ Ğ½Ğ°Ğ¿Ñ€ÑĞ¼ÑƒÑ â€” Ñ‚ĞµÑĞ½Ğ¾ ÑĞ²ÑĞ·Ğ°Ğ½Ğ½Ñ‹Ğ¹ ĞºĞ¾Ğ´!
    private val emailSender = SmtpEmailSender()
    private val paymentGateway = StripePaymentGateway()
    
    fun createOrder(orderDto: OrderDto): Order {
        // ĞĞµ Ğ¼Ğ¾Ğ¶ĞµĞ¼ Ğ¿Ğ¾Ğ´Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ emailSender Ğ² Ñ‚ĞµÑÑ‚Ğ°Ñ…!
        emailSender.send(orderDto.userEmail, "Order", "Your order created")
        
        // ĞĞµ Ğ¼Ğ¾Ğ¶ĞµĞ¼ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ´Ñ€ÑƒĞ³Ğ¾Ğ¹ payment gateway Ğ±ĞµĞ· Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ ĞºĞ¾Ğ´Ğ°!
        val txId = paymentGateway.charge(orderDto.total, orderDto.cardToken)
        
        return Order(id = 1L, userId = orderDto.userId, transactionId = txId)
    }
}

// ĞŸÑ€Ğ¾Ğ±Ğ»ĞµĞ¼Ñ‹:
// 1. ĞĞµĞ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¿Ñ€Ğ¾Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ±ĞµĞ· Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ SMTP/Stripe
// 2. ĞĞµĞ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ·Ğ°Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ SMTP Ğ½Ğ° SendGrid Ğ±ĞµĞ· Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ OrderServiceBad
// 3. Ğ¢ĞµÑĞ½Ğ¾ ÑĞ²ÑĞ·Ğ°Ğ½Ğ½Ñ‹Ğ¹ ĞºĞ¾Ğ´ â€” high-level Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ñ‚ Ğ¾Ñ‚ low-level Ğ½Ğ°Ğ¿Ñ€ÑĞ¼ÑƒÑ

// Ğ¥ĞĞ ĞĞ¨Ğ: ÑĞ¾Ğ±Ğ»ÑĞ´ĞµĞ½Ğ¸Ğµ DIP Ñ‡ĞµÑ€ĞµĞ· Ğ°Ğ±ÑÑ‚Ñ€Ğ°ĞºÑ†Ğ¸Ğ¸
interface EmailSender {
    fun send(to: String, subject: String, body: String)
}

interface PaymentGateway {
    fun charge(amount: BigDecimal, cardToken: String): String
}

// ĞšĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½Ñ‹Ğµ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ (low-level)
@Component
class SmtpEmailSenderImpl : EmailSender {
    override fun send(to: String, subject: String, body: String) {
        println("Sending email via SMTP to $to")
        // SMTP Ğ»Ğ¾Ğ³Ğ¸ĞºĞ°
    }
}

@Component
class SendGridEmailSenderImpl : EmailSender {
    override fun send(to: String, subject: String, body: String) {
        println("Sending email via SendGrid to $to")
        // SendGrid API Ğ»Ğ¾Ğ³Ğ¸ĞºĞ°
    }
}

@Component
class StripePaymentGatewayImpl : PaymentGateway {
    override fun charge(amount: BigDecimal, cardToken: String): String {
        println("Charging $amount via Stripe")
        return "stripe_tx_${UUID.randomUUID()}"
    }
}

@Component
class PayPalPaymentGatewayImpl : PaymentGateway {
    override fun charge(amount: BigDecimal, cardToken: String): String {
        println("Charging $amount via PayPal")
        return "paypal_tx_${UUID.randomUUID()}"
    }
}

// High-level Ğ¼Ğ¾Ğ´ÑƒĞ»ÑŒ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ñ‚ Ğ¾Ñ‚ ĞĞ‘Ğ¡Ğ¢Ğ ĞĞšĞ¦Ğ˜Ğ™, Ğ° Ğ½Ğµ ĞºĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½Ñ‹Ñ… Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¹
@Service
class OrderService(
    private val emailSender: EmailSender,           // ĞĞ±ÑÑ‚Ñ€Ğ°ĞºÑ†Ğ¸Ñ!
    private val paymentGateway: PaymentGateway,     // ĞĞ±ÑÑ‚Ñ€Ğ°ĞºÑ†Ğ¸Ñ!
    private val orderRepository: OrderRepository
) {
    
    fun createOrder(orderDto: OrderDto): Order {
        // Ğ Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµĞ¼ Ñ Ğ°Ğ±ÑÑ‚Ñ€Ğ°ĞºÑ†Ğ¸ÑĞ¼Ğ¸ â€” Ğ½Ğµ Ğ·Ğ½Ğ°ĞµĞ¼, ĞºĞ°ĞºĞ°Ñ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ²Ğ½ÑƒÑ‚Ñ€Ğ¸
        val txId = paymentGateway.charge(orderDto.total, orderDto.cardToken)
        
        val order = Order(
            userId = orderDto.userId,
            items = orderDto.items,
            total = orderDto.total,
            transactionId = txId
        )
        val savedOrder = orderRepository.save(order)
        
        emailSender.send(
            to = orderDto.userEmail,
            subject = "Ğ—Ğ°ĞºĞ°Ğ· ÑĞ¾Ğ·Ğ´Ğ°Ğ½",
            body = "Ğ’Ğ°Ñˆ Ğ·Ğ°ĞºĞ°Ğ· #${savedOrder.id} ÑĞ¾Ğ·Ğ´Ğ°Ğ½. Ğ¡ÑƒĞ¼Ğ¼Ğ°: ${savedOrder.total} Ñ€ÑƒĞ±."
        )
        
        return savedOrder
    }
}

// ĞšĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ: Ğ²Ñ‹Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ ĞºĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½Ñ‹Ğµ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸
@Configuration
class AppConfig {
    
    @Bean
    @Primary
    fun emailSender(): EmailSender {
        // Ğ›ĞµĞ³ĞºĞ¾ Ğ¿ĞµÑ€ĞµĞºĞ»ÑÑ‡Ğ°ĞµĞ¼ÑÑ Ğ¼ĞµĞ¶Ğ´Ñƒ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸ÑĞ¼Ğ¸ Ñ‡ĞµÑ€ĞµĞ· ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ
        return if (isProduction()) {
            SendGridEmailSenderImpl()
        } else {
            SmtpEmailSenderImpl()
        }
    }
    
    @Bean
    @Primary
    fun paymentGateway(): PaymentGateway {
        return StripePaymentGatewayImpl()
        // Ğ—Ğ°Ğ²Ñ‚Ñ€Ğ° Ğ¼Ğ¾Ğ¶ĞµĞ¼ Ğ»ĞµĞ³ĞºĞ¾ Ğ·Ğ°Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ½Ğ° PayPalPaymentGatewayImpl()
    }
    
    private fun isProduction(): Boolean = System.getenv("ENV") == "production"
}

// Ğ¢Ğ•Ğ¡Ğ¢: Ñ‚ĞµĞ¿ĞµÑ€ÑŒ Ğ»ĞµĞ³ĞºĞ¾ Ğ¿Ğ¾Ğ´Ğ¼ĞµĞ½ÑÑ‚ÑŒ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸
@Test
fun `should create order and send email`() {
    // ĞœĞ¾ĞºĞ¸ Ğ²Ğ¼ĞµÑÑ‚Ğ¾ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ñ‹Ñ… Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¹
    val emailSender = mockk<EmailSender>(relaxed = true)
    val paymentGateway = mockk<PaymentGateway>()
    val orderRepository = mockk<OrderRepository>()
    
    every { paymentGateway.charge(any(), any()) } returns "test_tx_123"
    every { orderRepository.save(any()) } returns testOrder
    
    val service = OrderService(emailSender, paymentGateway, orderRepository)
    val result = service.createOrder(testOrderDto)
    
    // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ²Ğ·Ğ°Ğ¸Ğ¼Ğ¾Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ Ñ Ğ°Ğ±ÑÑ‚Ñ€Ğ°ĞºÑ†Ğ¸ÑĞ¼Ğ¸
    verify { paymentGateway.charge(testOrderDto.total, testOrderDto.cardToken) }
    verify { emailSender.send(testOrderDto.userEmail, any(), any()) }
    assertEquals("test_tx_123", result.transactionId)
}

// Ğ¢ĞµÑÑ‚ Ñ Ğ´Ñ€ÑƒĞ³Ğ¾Ğ¹ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸ĞµĞ¹
@Test
fun `should work with PayPal instead of Stripe`() {
    val paypalGateway = PayPalPaymentGatewayImpl()
    val service = OrderService(
        emailSender = SmtpEmailSenderImpl(),
        paymentGateway = paypalGateway, // Ğ›ĞµĞ³ĞºĞ¾ Ğ·Ğ°Ğ¼ĞµĞ½ÑĞµĞ¼ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ!
        orderRepository = mockk(relaxed = true)
    )
    
    val result = service.createOrder(testOrderDto)
    assertTrue(result.transactionId.startsWith("paypal_tx"))
}
```
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

### ĞšĞ•Ğ™Ğ¡ #6 | Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ: Middle
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
**Ğ’ĞĞŸĞ ĞĞ¡:**
Ğ£ Ğ²Ğ°Ñ ĞµÑÑ‚ÑŒ ĞºĞ»Ğ°ÑÑ `UserValidator` Ñ 10 Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ°Ğ¼Ğ¸ Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ğ¸. ĞšĞ°Ğ¶Ğ´Ñ‹Ğ¹ Ñ€Ğ°Ğ· Ğ¿Ñ€Ğ¸ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğ¸ 
Ğ½Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾Ğ»Ñ Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑÑ‚ÑŒ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ğ¼ĞµÑ‚Ğ¾Ğ´ Ğ¸ Ğ¸Ğ·Ğ¼ĞµĞ½ÑÑ‚ÑŒ Ğ³Ğ»Ğ°Ğ²Ğ½Ñ‹Ğ¹ Ğ¼ĞµÑ‚Ğ¾Ğ´ `validate()`. ĞšĞ°Ğº 
Ğ¿Ñ€Ğ¸Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Chain of Responsibility Ğ´Ğ»Ñ ÑƒĞ¿Ñ€Ğ¾Ñ‰ĞµĞ½Ğ¸Ñ?

**ĞĞ¢Ğ’Ğ•Ğ¢:**
Chain of Responsibility Ğ¿Ğ¾Ğ·Ğ²Ğ¾Ğ»ÑĞµÑ‚ Ğ¿ĞµÑ€ĞµĞ´Ğ°Ğ²Ğ°Ñ‚ÑŒ Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ Ğ¿Ğ¾ Ñ†ĞµĞ¿Ğ¾Ñ‡ĞºĞµ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸ĞºĞ¾Ğ². ĞšĞ°Ğ¶Ğ´Ñ‹Ğ¹ 
Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº Ñ€ĞµÑˆĞ°ĞµÑ‚, Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ°Ñ‚Ñ‹Ğ²Ğ°Ñ‚ÑŒ Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ Ğ¸Ğ»Ğ¸ Ğ¿ĞµÑ€ĞµĞ´Ğ°Ñ‚ÑŒ ÑĞ»ĞµĞ´ÑƒÑÑ‰ĞµĞ¼Ñƒ.

ĞŸÑ€ĞµĞ¸Ğ¼ÑƒÑ‰ĞµÑÑ‚Ğ²Ğ°:
- Ğ›ĞµĞ³ĞºĞ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑÑ‚ÑŒ Ğ½Ğ¾Ğ²Ñ‹Ğµ Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ‚Ğ¾Ñ€Ñ‹ Ğ±ĞµĞ· Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰ĞµĞ³Ğ¾ ĞºĞ¾Ğ´Ğ° (OCP)
- ĞšĞ°Ğ¶Ğ´Ñ‹Ğ¹ Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ‚Ğ¾Ñ€ Ğ½ĞµĞ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼ Ğ¸ Ñ‚ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ÑÑ Ğ¾Ñ‚Ğ´ĞµĞ»ÑŒĞ½Ğ¾
- Ğ“Ğ¸Ğ±ĞºĞ°Ñ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° Ğ¿Ğ¾Ñ€ÑĞ´ĞºĞ° Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ğ¸

**ĞŸĞĞ§Ğ•ĞœĞ£ Ğ­Ğ¢Ğ Ğ’ĞĞ–ĞĞ:**
- ĞœĞ°ÑÑˆÑ‚Ğ°Ğ±Ğ¸Ñ€ÑƒĞµĞ¼Ğ¾ÑÑ‚ÑŒ: Ğ½Ğ¾Ğ²Ñ‹Ğµ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»Ğ° Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ğ¸ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑÑÑ‚ÑÑ Ğ±ĞµĞ· Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ ĞºĞ¾Ğ´Ğ°
- ĞŸĞµÑ€ĞµĞ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ: Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ‚Ğ¾Ñ€Ñ‹ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ ĞºĞ¾Ğ¼Ğ±Ğ¸Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ² Ñ€Ğ°Ğ·Ğ½Ñ‹Ğµ Ñ†ĞµĞ¿Ğ¾Ñ‡ĞºĞ¸
- Ğ§Ğ¸ÑÑ‚Ğ¾Ñ‚Ğ° ĞºĞ¾Ğ´Ğ°: ĞºĞ°Ğ¶Ğ´Ñ‹Ğ¹ Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ‚Ğ¾Ñ€ Ğ¸Ğ¼ĞµĞµÑ‚ Ğ¾Ğ´Ğ½Ñƒ Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²ĞµĞ½Ğ½Ğ¾ÑÑ‚ÑŒ

**ĞŸĞ Ğ˜ĞœĞ•Ğ  ĞšĞĞ”Ğ:**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```kotlin
// ĞŸĞ›ĞĞ¥Ğ: Ğ¼Ğ¾Ğ½Ğ¾Ğ»Ğ¸Ñ‚Ğ½Ñ‹Ğ¹ Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ‚Ğ¾Ñ€
class UserValidatorBad {
    
    fun validate(user: UserDto): ValidationResult {
        val errors = mutableListOf<String>()
        
        // Email validation
        if (user.email.isBlank()) {
            errors.add("Email is required")
        } else if (!user.email.matches(Regex(".+@.+\\..+"))) {
            errors.add("Email format is invalid")
        }
        
        // Password validation
        if (user.password.length < 8) {
            errors.add("Password must be at least 8 characters")
        }
        if (!user.password.any { it.isDigit() }) {
            errors.add("Password must contain at least one digit")
        }
        if (!user.password.any { it.isUpperCase() }) {
            errors.add("Password must contain at least one uppercase letter")
        }
        
        // Age validation
        if (user.age < 18) {
            errors.add("User must be at least 18 years old")
        }
        if (user.age > 120) {
            errors.add("Invalid age")
        }
        
        // Phone validation
        if (!user.phone.matches(Regex("\\+?[0-9]{10,15}"))) {
            errors.add("Phone format is invalid")
        }
        
        // ĞŸÑ€Ğ¸ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğ¸ Ğ½Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾Ğ»Ñ Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ˜Ğ—ĞœĞ•ĞĞ¯Ğ¢Ğ¬ ÑÑ‚Ğ¾Ñ‚ Ğ¼ĞµÑ‚Ğ¾Ğ´!
        
        return ValidationResult(errors.isEmpty(), errors)
    }
}

// Ğ¥ĞĞ ĞĞ¨Ğ: Chain of Responsibility
interface ValidationHandler {
    fun validate(user: UserDto, errors: MutableList<String>)
}

abstract class BaseValidationHandler : ValidationHandler {
    protected var next: ValidationHandler? = null
    
    fun setNext(handler: ValidationHandler): ValidationHandler {
        this.next = handler
        return handler
    }
    
    override fun validate(user: UserDto, errors: MutableList<String>) {
        doValidate(user, errors)
        next?.validate(user, errors)
    }
    
    protected abstract fun doValidate(user: UserDto, errors: MutableList<String>)
}

class EmailValidationHandler : BaseValidationHandler() {
    override fun doValidate(user: UserDto, errors: MutableList<String>) {
        if (user.email.isBlank()) {
            errors.add("Email is required")
            return
        }
        if (!user.email.matches(Regex(".+@.+\\..+"))) {
            errors.add("Email format is invalid")
        }
    }
}

class PasswordValidationHandler : BaseValidationHandler() {
    override fun doValidate(user: UserDto, errors: MutableList<String>) {
        if (user.password.length < 8) {
            errors.add("Password must be at least 8 characters")
        }
        if (!user.password.any { it.isDigit() }) {
            errors.add("Password must contain at least one digit")
        }
        if (!user.password.any { it.isUpperCase() }) {
            errors.add("Password must contain at least one uppercase letter")
        }
    }
}

class AgeValidationHandler : BaseValidationHandler() {
    override fun doValidate(user: UserDto, errors: MutableList<String>) {
        if (user.age < 18) {
            errors.add("User must be at least 18 years old")
        } else if (user.age > 120) {
            errors.add("Invalid age")
        }
    }
}

class PhoneValidationHandler : BaseValidationHandler() {
    override fun doValidate(user: UserDto, errors: MutableList<String>) {
        if (!user.phone.matches(Regex("\\+?[0-9]{10,15}"))) {
            errors.add("Phone format is invalid")
        }
    }
}

// ĞĞ¾Ğ²Ñ‹Ğ¹ Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ‚Ğ¾Ñ€ â€” Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ ĞºĞ»Ğ°ÑÑ, ĞĞ• Ğ˜Ğ—ĞœĞ•ĞĞ¯Ğ¯ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰Ğ¸Ğµ
class UsernameValidationHandler : BaseValidationHandler() {
    override fun doValidate(user: UserDto, errors: MutableList<String>) {
        if (user.username.length < 3) {
            errors.add("Username must be at least 3 characters")
        }
        if (!user.username.matches(Regex("[a-zA-Z0-9_]+"))) {
            errors.add("Username can only contain letters, numbers and underscore")
        }
    }
}

@Service
class UserValidator {
    private val chain: ValidationHandler
    
    init {
        // Ğ¡Ñ‚Ñ€Ğ¾Ğ¸Ğ¼ Ñ†ĞµĞ¿Ğ¾Ñ‡ĞºÑƒ Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ‚Ğ¾Ñ€Ğ¾Ğ²
        val emailHandler = EmailValidationHandler()
        val passwordHandler = PasswordValidationHandler()
        val ageHandler = AgeValidationHandler()
        val phoneHandler = PhoneValidationHandler()
        val usernameHandler = UsernameValidationHandler()
        
        emailHandler
            .setNext(passwordHandler)
            .setNext(ageHandler)
            .setNext(phoneHandler)
            .setNext(usernameHandler)
        
        chain = emailHandler
    }
    
    fun validate(user: UserDto): ValidationResult {
        val errors = mutableListOf<String>()
        chain.validate(user, errors)
        return ValidationResult(errors.isEmpty(), errors)
    }
}

// ĞĞ›Ğ¬Ğ¢Ğ•Ğ ĞĞĞ¢Ğ˜Ğ’Ğ: Ñ‡ĞµÑ€ĞµĞ· Spring Ğ¸ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ
@Component
interface UserValidationRule {
    fun validate(user: UserDto): List<String>
}

@Component
class EmailValidationRule : UserValidationRule {
    override fun validate(user: UserDto): List<String> {
        val errors = mutableListOf<String>()
        if (user.email.isBlank()) errors.add("Email is required")
        else if (!user.email.matches(Regex(".+@.+\\..+"))) {
            errors.add("Email format is invalid")
        }
        return errors
    }
}

@Component
class PasswordValidationRule : UserValidationRule {
    override fun validate(user: UserDto): List<String> {
        val errors = mutableListOf<String>()
        if (user.password.length < 8) {
            errors.add("Password must be at least 8 characters")
        }
        if (!user.password.any { it.isDigit() }) {
            errors.add("Password must contain at least one digit")
        }
        return errors
    }
}

@Service
class CompositeUserValidator(
    private val rules: List<UserValidationRule> // Spring Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ Ğ¸Ğ½Ğ¶ĞµĞºÑ‚Ğ¸Ñ‚ Ğ²ÑĞµ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»Ğ°
) {
    fun validate(user: UserDto): ValidationResult {
        val allErrors = rules.flatMap { it.validate(user) }
        return ValidationResult(allErrors.isEmpty(), allErrors)
    }
}

// Ğ¢Ğ•Ğ¡Ğ¢: Ğ»ĞµĞ³ĞºĞ¾ Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¾Ñ‚Ğ´ĞµĞ»ÑŒĞ½Ñ‹Ğµ Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ‚Ğ¾Ñ€Ñ‹
@Test
fun `should validate email format`() {
    val rule = EmailValidationRule()
    
    val validUser = UserDto(email = "test@example.com")
    val invalidUser = UserDto(email = "invalid-email")
    
    assertTrue(rule.validate(validUser).isEmpty())
    assertEquals(1, rule.validate(invalidUser).size)
}

@Test
fun `should combine multiple validators`() {
    val validator = CompositeUserValidator(
        listOf(EmailValidationRule(), PasswordValidationRule())
    )
    
    val user = UserDto(
        email = "invalid",
        password = "weak"
    )
    
    val result = validator.validate(user)
    assertFalse(result.isValid)
    assertTrue(result.errors.size >= 2) // Email + Password errors
}
```
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

### ĞšĞ•Ğ™Ğ¡ #7 | Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ: Senior
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
**Ğ’ĞĞŸĞ ĞĞ¡:**
Ğ£ Ğ²Ğ°Ñ ĞµÑÑ‚ÑŒ Ğ¼ĞµÑ‚Ğ¾Ğ´, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¹ Ğ³ĞµĞ½ĞµÑ€Ğ¸Ñ€ÑƒĞµÑ‚ Ğ¾Ñ‚Ñ‡ĞµÑ‚ Ğ² Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ°Ñ… PDF, Excel, CSV. Ğ¡ĞµĞ¹Ñ‡Ğ°Ñ ÑÑ‚Ğ¾ 
Ğ±Ğ¾Ğ»ÑŒÑˆĞ¾Ğ¹ `when` Ğ¿Ğ¾ Ñ‚Ğ¸Ğ¿Ñƒ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ°. Code reviewer Ğ¿Ñ€ĞµĞ´Ğ»Ğ°Ğ³Ğ°ĞµÑ‚ Ğ¿Ñ€Ğ¸Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Template Method 
pattern. ĞšĞ°Ğº ÑÑ‚Ğ¾ ÑĞ´ĞµĞ»Ğ°Ñ‚ÑŒ Ğ¸ Ğ² Ñ‡ĞµĞ¼ Ğ²Ñ‹Ğ³Ğ¾Ğ´Ğ°?

**ĞĞ¢Ğ’Ğ•Ğ¢:**
Template Method Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµÑ‚ ÑĞºĞµĞ»ĞµÑ‚ Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼Ğ° Ğ² Ğ±Ğ°Ğ·Ğ¾Ğ²Ğ¾Ğ¼ ĞºĞ»Ğ°ÑÑĞµ, Ğ¿Ğ¾Ğ·Ğ²Ğ¾Ğ»ÑÑ Ğ¿Ğ¾Ğ´ĞºĞ»Ğ°ÑÑĞ°Ğ¼ 
Ğ¿ĞµÑ€ĞµĞ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ÑÑ‚ÑŒ Ğ¾Ñ‚Ğ´ĞµĞ»ÑŒĞ½Ñ‹Ğµ ÑˆĞ°Ğ³Ğ¸ Ğ±ĞµĞ· Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñ‹ Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼Ğ°.

Ğ’Ñ‹Ğ³Ğ¾Ğ´Ñ‹:
- Ğ˜Ğ·Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ÑÑ Ğ¾Ñ‚ Ğ´ÑƒĞ±Ğ»Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ ĞºĞ¾Ğ´Ğ° (Ğ¾Ğ±Ñ‰Ğ¸Ğµ ÑˆĞ°Ğ³Ğ¸ Ğ² Ğ±Ğ°Ğ·Ğ¾Ğ²Ğ¾Ğ¼ ĞºĞ»Ğ°ÑÑĞµ)
- Ğ“Ğ¸Ğ±ĞºĞ¾ÑÑ‚ÑŒ: Ğ»ĞµĞ³ĞºĞ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑÑ‚ÑŒ Ğ½Ğ¾Ğ²Ñ‹Ğµ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ñ‹
- Ğ¯Ğ²Ğ½Ğ°Ñ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ°: Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼ Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ Ğ¾Ñ‚Ñ‡ĞµÑ‚Ğ° Ğ²Ğ¸Ğ´ĞµĞ½ Ğ² Ğ¾Ğ´Ğ½Ğ¾Ğ¼ Ğ¼ĞµÑÑ‚Ğµ

**ĞŸĞĞ§Ğ•ĞœĞ£ Ğ­Ğ¢Ğ Ğ’ĞĞ–ĞĞ:**
- Ğ£ÑÑ‚Ñ€Ğ°Ğ½ÑĞµÑ‚ Ğ´ÑƒĞ±Ğ»Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ: Ğ¾Ğ±Ñ‰Ğ°Ñ Ğ»Ğ¾Ğ³Ğ¸ĞºĞ° Ğ½Ğµ Ğ¿Ğ¾Ğ²Ñ‚Ğ¾Ñ€ÑĞµÑ‚ÑÑ Ğ² ĞºĞ°Ğ¶Ğ´Ğ¾Ğ¼ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğµ
- ĞĞ±Ğ»ĞµĞ³Ñ‡Ğ°ĞµÑ‚ Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶ĞºÑƒ: Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ Ğ² Ğ¾Ğ±Ñ‰ĞµĞ¼ Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼Ğµ Ğ½Ğµ Ñ‚Ñ€ĞµĞ±ÑƒÑÑ‚ Ğ¿Ñ€Ğ°Ğ²Ğ¾Ğº Ğ²Ğ¾ Ğ²ÑĞµÑ… Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ°Ñ…
- Ğ Ğ°ÑÑˆĞ¸Ñ€ÑĞµĞ¼Ğ¾ÑÑ‚ÑŒ: Ğ½Ğ¾Ğ²Ñ‹Ğµ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ñ‹ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑÑÑ‚ÑÑ Ğ±ĞµĞ· Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰ĞµĞ³Ğ¾ ĞºĞ¾Ğ´Ğ°

**ĞŸĞ Ğ˜ĞœĞ•Ğ  ĞšĞĞ”Ğ:**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```kotlin
// ĞŸĞ›ĞĞ¥Ğ: Ğ´ÑƒĞ±Ğ»Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ ĞºĞ¾Ğ´Ğ° Ğ² ĞºĞ°Ğ¶Ğ´Ğ¾Ğ¼ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğµ
@Service
class ReportGeneratorBad(
    private val dataRepository: DataRepository
) {
    
    fun generateReport(format: String, startDate: LocalDate, endDate: LocalDate): ByteArray {
        return when (format) {
            "PDF" -> {
                // 1. Fetch data
                val data = dataRepository.findByDateRange(startDate, endDate)
                
                // 2. Transform data
                val transformed = data.map { 
                    TransformedData(it.id, it.value, it.date) 
                }
                
                // 3. Generate PDF
                val pdf = PdfDocument()
                pdf.addTitle("Report $startDate - $endDate")
                transformed.forEach { pdf.addRow(it.id, it.value, it.date) }
                pdf.toByteArray()
            }
            "EXCEL" -> {
                // 1. Fetch data (Ğ”Ğ£Ğ‘Ğ›Ğ˜Ğ ĞĞ’ĞĞĞ˜Ğ•!)
                val data = dataRepository.findByDateRange(startDate, endDate)
                
                // 2. Transform data (Ğ”Ğ£Ğ‘Ğ›Ğ˜Ğ ĞĞ’ĞĞĞ˜Ğ•!)
                val transformed = data.map { 
                    TransformedData(it.id, it.value, it.date) 
                }
                
                // 3. Generate Excel
                val workbook = XSSFWorkbook()
                val sheet = workbook.createSheet("Report")
                sheet.createRow(0).apply {
                    createCell(0).setCellValue("Report $startDate - $endDate")
                }
                transformed.forEachIndexed { index, data ->
                    sheet.createRow(index + 1).apply {
                        createCell(0).setCellValue(data.id.toDouble())
                        createCell(1).setCellValue(data.value.toDouble())
                        createCell(2).setCellValue(data.date.toString())
                    }
                }
                workbook.toByteArray()
            }
            "CSV" -> {
                // 1. Fetch data (Ğ”Ğ£Ğ‘Ğ›Ğ˜Ğ ĞĞ’ĞĞĞ˜Ğ•!)
                val data = dataRepository.findByDateRange(startDate, endDate)
                
                // 2. Transform data (Ğ”Ğ£Ğ‘Ğ›Ğ˜Ğ ĞĞ’ĞĞĞ˜Ğ•!)
                val transformed = data.map { 
                    TransformedData(it.id, it.value, it.date) 
                }
                
                // 3. Generate CSV
                val csv = StringBuilder()
                csv.append("Report $startDate - $endDate\n")
                csv.append("ID,Value,Date\n")
                transformed.forEach { 
                    csv.append("${it.id},${it.value},${it.date}\n") 
                }
                csv.toString().toByteArray()
            }
            else -> throw IllegalArgumentException("Unknown format: $format")
        }
    }
}

// Ğ¥ĞĞ ĞĞ¨Ğ: Template Method â€” Ğ¾Ğ±Ñ‰Ğ¸Ğ¹ Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼ Ğ² Ğ±Ğ°Ğ·Ğ¾Ğ²Ğ¾Ğ¼ ĞºĞ»Ğ°ÑÑĞµ
abstract class ReportGenerator(
    protected val dataRepository: DataRepository
) {
    
    // Ğ¨Ğ°Ğ±Ğ»Ğ¾Ğ½Ğ½Ñ‹Ğ¹ Ğ¼ĞµÑ‚Ğ¾Ğ´ â€” Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµÑ‚ ÑĞºĞµĞ»ĞµÑ‚ Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼Ğ°
    fun generateReport(startDate: LocalDate, endDate: LocalDate): ByteArray {
        // Ğ¨Ğ°Ğ³ 1: Fetch data (Ğ¾Ğ±Ñ‰Ğ¸Ğ¹ Ğ´Ğ»Ñ Ğ²ÑĞµÑ…)
        val data = fetchData(startDate, endDate)
        
        // Ğ¨Ğ°Ğ³ 2: Transform data (Ğ¾Ğ±Ñ‰Ğ¸Ğ¹ Ğ´Ğ»Ñ Ğ²ÑĞµÑ…)
        val transformed = transformData(data)
        
        // Ğ¨Ğ°Ğ³ 3: Generate header (Ğ´ĞµĞ»ĞµĞ³Ğ¸Ñ€ÑƒĞµÑ‚ÑÑ Ğ¿Ğ¾Ğ´ĞºĞ»Ğ°ÑÑĞ°Ğ¼)
        val header = generateHeader(startDate, endDate)
        
        // Ğ¨Ğ°Ğ³ 4: Generate body (Ğ´ĞµĞ»ĞµĞ³Ğ¸Ñ€ÑƒĞµÑ‚ÑÑ Ğ¿Ğ¾Ğ´ĞºĞ»Ğ°ÑÑĞ°Ğ¼)
        val body = generateBody(transformed)
        
        // Ğ¨Ğ°Ğ³ 5: Generate footer (Ğ¾Ğ¿Ñ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ñ…ÑƒĞº)
        val footer = generateFooter()
        
        // Ğ¨Ğ°Ğ³ 6: Assemble report (Ğ´ĞµĞ»ĞµĞ³Ğ¸Ñ€ÑƒĞµÑ‚ÑÑ Ğ¿Ğ¾Ğ´ĞºĞ»Ğ°ÑÑĞ°Ğ¼)
        return assembleReport(header, body, footer)
    }
    
    // ĞĞ±Ñ‰Ğ¸Ğµ ÑˆĞ°Ğ³Ğ¸ (Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ğ½Ñ‹ Ğ² Ğ±Ğ°Ğ·Ğ¾Ğ²Ğ¾Ğ¼ ĞºĞ»Ğ°ÑÑĞµ)
    protected open fun fetchData(startDate: LocalDate, endDate: LocalDate): List<RawData> {
        return dataRepository.findByDateRange(startDate, endDate)
    }
    
    protected open fun transformData(data: List<RawData>): List<TransformedData> {
        return data.map { TransformedData(it.id, it.value, it.date) }
    }
    
    // ĞĞ±ÑÑ‚Ñ€Ğ°ĞºÑ‚Ğ½Ñ‹Ğµ ÑˆĞ°Ğ³Ğ¸ (Ğ´Ğ¾Ğ»Ğ¶Ğ½Ñ‹ Ğ±Ñ‹Ñ‚ÑŒ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ğ½Ñ‹ Ğ¿Ğ¾Ğ´ĞºĞ»Ğ°ÑÑĞ°Ğ¼Ğ¸)
    protected abstract fun generateHeader(startDate: LocalDate, endDate: LocalDate): Any
    protected abstract fun generateBody(data: List<TransformedData>): Any
    protected abstract fun assembleReport(header: Any, body: Any, footer: Any?): ByteArray
    
    // Ğ¥ÑƒĞº (Ğ¾Ğ¿Ñ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¼ĞµÑ‚Ğ¾Ğ´ Ñ Ğ´ĞµÑ„Ğ¾Ğ»Ñ‚Ğ½Ğ¾Ğ¹ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸ĞµĞ¹)
    protected open fun generateFooter(): Any? = null
}

@Component
class PdfReportGenerator(
    dataRepository: DataRepository
) : ReportGenerator(dataRepository) {
    
    override fun generateHeader(startDate: LocalDate, endDate: LocalDate): PdfElement {
        return PdfElement.Title("Report $startDate - $endDate")
    }
    
    override fun generateBody(data: List<TransformedData>): PdfElement {
        val rows = data.map { 
            PdfElement.Row(listOf(it.id.toString(), it.value.toString(), it.date.toString())) 
        }
        return PdfElement.Table(rows)
    }
    
    override fun generateFooter(): PdfElement {
        return PdfElement.Footer("Generated at ${LocalDateTime.now()}")
    }
    
    override fun assembleReport(header: Any, body: Any, footer: Any?): ByteArray {
        val pdf = PdfDocument()
        pdf.add(header as PdfElement)
        pdf.add(body as PdfElement)
        footer?.let { pdf.add(it as PdfElement) }
        return pdf.toByteArray()
    }
}

@Component
class ExcelReportGenerator(
    dataRepository: DataRepository
) : ReportGenerator(dataRepository) {
    
    override fun generateHeader(startDate: LocalDate, endDate: LocalDate): XSSFRow {
        val workbook = XSSFWorkbook()
        val sheet = workbook.createSheet("Report")
        return sheet.createRow(0).apply {
            createCell(0).setCellValue("Report $startDate - $endDate")
        }
    }
    
    override fun generateBody(data: List<TransformedData>): List<XSSFRow> {
        val workbook = XSSFWorkbook()
        val sheet = workbook.createSheet("Report")
        
        return data.mapIndexed { index, item ->
            sheet.createRow(index + 1).apply {
                createCell(0).setCellValue(item.id.toDouble())
                createCell(1).setCellValue(item.value.toDouble())
                createCell(2).setCellValue(item.date.toString())
            }
        }
    }
    
    override fun assembleReport(header: Any, body: Any, footer: Any?): ByteArray {
        val workbook = XSSFWorkbook()
        val sheet = workbook.createSheet("Report")
        
        // Add header
        sheet.createRow(0).apply {
            createCell(0).setCellValue((header as XSSFRow).getCell(0).stringCellValue)
        }
        
        // Add body
        @Suppress("UNCHECKED_CAST")
        val rows = body as List<XSSFRow>
        rows.forEachIndexed { index, row ->
            val newRow = sheet.createRow(index + 1)
            row.cellIterator().forEach { cell ->
                newRow.createCell(cell.columnIndex).setCellValue(cell.toString())
            }
        }
        
        return workbook.toByteArray()
    }
}

@Component
class CsvReportGenerator(
    dataRepository: DataRepository
) : ReportGenerator(dataRepository) {
    
    override fun generateHeader(startDate: LocalDate, endDate: LocalDate): String {
        return "Report $startDate - $endDate\nID,Value,Date\n"
    }
    
    override fun generateBody(data: List<TransformedData>): String {
        return data.joinToString("\n") { "${it.id},${it.value},${it.date}" }
    }
    
    override fun assembleReport(header: Any, body: Any, footer: Any?): ByteArray {
        val csv = StringBuilder()
        csv.append(header as String)
        csv.append(body as String)
        footer?.let { csv.append("\n").append(it as String) }
        return csv.toString().toByteArray()
    }
}

// Ğ¤Ğ°Ğ±Ñ€Ğ¸ĞºĞ° Ğ´Ğ»Ñ Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€Ğ°
@Service
class ReportService(
    private val generators: Map<String, ReportGenerator> // Spring Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ ÑĞ¾Ğ·Ğ´Ğ°ÑÑ‚ Map
) {
    
    fun generateReport(format: String, startDate: LocalDate, endDate: LocalDate): ByteArray {
        val generator = generators[format.lowercase() + "ReportGenerator"]
            ?: throw IllegalArgumentException("Unknown format: $format")
        
        return generator.generateReport(startDate, endDate)
    }
}

// Ğ¢Ğ•Ğ¡Ğ¢: Ğ»ĞµĞ³ĞºĞ¾ Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¾Ğ±Ñ‰Ğ¸Ğ¹ Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼ Ğ¸ Ğ¾Ñ‚Ğ´ĞµĞ»ÑŒĞ½Ñ‹Ğµ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ñ‹
@Test
fun `should use common data fetching logic`() {
    val dataRepository = mockk<DataRepository>()
    every { dataRepository.findByDateRange(any(), any()) } returns listOf(testData)
    
    val generator = CsvReportGenerator(dataRepository)
    generator.generateReport(LocalDate.now(), LocalDate.now())
    
    // ĞĞ±Ñ‰Ğ¸Ğ¹ Ğ¼ĞµÑ‚Ğ¾Ğ´ fetchData Ğ²Ñ‹Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ÑÑ Ğ´Ğ»Ñ Ğ²ÑĞµÑ… Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¾Ğ²
    verify(exactly = 1) { dataRepository.findByDateRange(any(), any()) }
}

@Test
fun `should generate PDF with footer`() {
    val generator = PdfReportGenerator(mockk(relaxed = true))
    val report = generator.generateReport(LocalDate.now(), LocalDate.now())
    
    assertNotNull(report)
    assertTrue(report.isNotEmpty())
    // PDF Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ°Ñ‚ÑŒ footer
}

@Test
fun `should generate CSV without footer`() {
    val generator = CsvReportGenerator(mockk(relaxed = true))
    val report = generator.generateReport(LocalDate.now(), LocalDate.now())
    
    val content = String(report)
    assertFalse(content.contains("Generated at"))
    // CSV Ğ½Ğµ Ğ¿ĞµÑ€ĞµĞ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµÑ‚ generateFooter(), Ğ¿Ğ¾ÑÑ‚Ğ¾Ğ¼Ñƒ footer = null
}
```
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

### ĞšĞ•Ğ™Ğ¡ #8 | Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ: Middle
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
**Ğ’ĞĞŸĞ ĞĞ¡:**
Ğ£ Ğ²Ğ°Ñ ĞµÑÑ‚ÑŒ ĞºĞ»Ğ°ÑÑ `OrderProcessor`, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¹ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ°Ñ‚Ñ‹Ğ²Ğ°ĞµÑ‚ Ğ·Ğ°ĞºĞ°Ğ·Ñ‹ Ğ¿Ğ¾-Ñ€Ğ°Ğ·Ğ½Ğ¾Ğ¼Ñƒ Ğ² Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ 
Ğ¾Ñ‚ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ°. Ğ¡ĞµĞ¹Ñ‡Ğ°Ñ ÑÑ‚Ğ¾ Ğ±Ğ¾Ğ»ÑŒÑˆĞ¾Ğ¹ `when`. Code reviewer Ğ¿Ñ€ĞµĞ´Ğ»Ğ°Ğ³Ğ°ĞµÑ‚ Ğ¿Ñ€Ğ¸Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ State pattern. 
Ğ’ Ñ‡ĞµĞ¼ Ğ²Ñ‹Ğ³Ğ¾Ğ´Ğ° Ğ¸ ĞºĞ°Ğº Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ?

**ĞĞ¢Ğ’Ğ•Ğ¢:**
State pattern Ğ¿Ğ¾Ğ·Ğ²Ğ¾Ğ»ÑĞµÑ‚ Ğ¾Ğ±ÑŠĞµĞºÑ‚Ñƒ Ğ¸Ğ·Ğ¼ĞµĞ½ÑÑ‚ÑŒ Ğ¿Ğ¾Ğ²ĞµĞ´ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¸ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğ¸ Ğ²Ğ½ÑƒÑ‚Ñ€ĞµĞ½Ğ½ĞµĞ³Ğ¾ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ. 
Ğ’Ğ¼ĞµÑÑ‚Ğ¾ ÑƒÑĞ»Ğ¾Ğ²Ğ½Ñ‹Ñ… Ğ¾Ğ¿ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€Ğ¾Ğ² ÑĞ¾Ğ·Ğ´Ğ°ÑÑ‚ÑÑ Ğ¾Ñ‚Ğ´ĞµĞ»ÑŒĞ½Ñ‹Ğµ ĞºĞ»Ğ°ÑÑÑ‹ Ğ´Ğ»Ñ ĞºĞ°Ğ¶Ğ´Ğ¾Ğ³Ğ¾ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ.

Ğ’Ñ‹Ğ³Ğ¾Ğ´Ñ‹:
- Ğ£ÑÑ‚Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ Ğ±Ğ¾Ğ»ÑŒÑˆĞ¸Ñ… `when/switch`
- ĞšĞ°Ğ¶Ğ´Ğ¾Ğµ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ Ğ¸Ğ½ĞºĞ°Ğ¿ÑÑƒĞ»Ğ¸Ñ€ÑƒĞµÑ‚ ÑĞ²Ğ¾Ğµ Ğ¿Ğ¾Ğ²ĞµĞ´ĞµĞ½Ğ¸Ğµ
- Ğ›ĞµĞ³ĞºĞ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑÑ‚ÑŒ Ğ½Ğ¾Ğ²Ñ‹Ğµ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ
- Ğ¯Ğ²Ğ½Ñ‹Ğµ Ğ¿ĞµÑ€ĞµÑ…Ğ¾Ğ´Ñ‹ Ğ¼ĞµĞ¶Ğ´Ñƒ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸ÑĞ¼Ğ¸

**ĞŸĞĞ§Ğ•ĞœĞ£ Ğ­Ğ¢Ğ Ğ’ĞĞ–ĞĞ:**
- Ğ£Ğ¿Ñ€Ğ¾Ñ‰Ğ°ĞµÑ‚ ĞºĞ¾Ğ´: Ğ²Ğ¼ĞµÑÑ‚Ğ¾ Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ Ğ±Ğ¾Ğ»ÑŒÑˆĞ¾Ğ³Ğ¾ Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ° â€” Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¾ Ğ¼Ğ°Ğ»ĞµĞ½ÑŒĞºĞ¸Ñ… ĞºĞ»Ğ°ÑÑĞ¾Ğ²
- Ğ‘ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚ÑŒ: Ğ½ĞµĞ²Ğ°Ğ»Ğ¸Ğ´Ğ½Ñ‹Ğµ Ğ¿ĞµÑ€ĞµÑ…Ğ¾Ğ´Ñ‹ Ğ¼ĞµĞ¶Ğ´Ñƒ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸ÑĞ¼Ğ¸ Ğ¾Ñ‚Ğ»Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ÑÑ‚ÑÑ Ğ½Ğ° ÑÑ‚Ğ°Ğ¿Ğµ Ğ´Ğ¸Ğ·Ğ°Ğ¹Ğ½Ğ°
- Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµĞ¼Ğ¾ÑÑ‚ÑŒ: ĞºĞ°Ğ¶Ğ´Ğ¾Ğµ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ Ñ‚ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ÑÑ Ğ½ĞµĞ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾

**ĞŸĞ Ğ˜ĞœĞ•Ğ  ĞšĞĞ”Ğ:**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```kotlin
// ĞŸĞ›ĞĞ¥Ğ: Ğ±Ğ¾Ğ»ÑŒÑˆĞ¾Ğ¹ when Ğ´Ğ»Ñ Ñ€Ğ°Ğ·Ğ½Ñ‹Ñ… ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğ¹
enum class OrderStatus {
    PENDING, PAID, SHIPPED, DELIVERED, CANCELLED
}

@Service
class OrderProcessorBad(
    private val orderRepository: OrderRepository
) {
    
    fun processOrder(orderId: Long, action: String): Order {
        val order = orderRepository.findById(orderId)
            ?: throw NotFoundException("Order not found")
        
        when (order.status) {
            OrderStatus.PENDING -> {
                when (action) {
                    "pay" -> {
                        order.status = OrderStatus.PAID
                        sendPaymentConfirmation(order)
                    }
                    "cancel" -> {
                        order.status = OrderStatus.CANCELLED
                        refundPayment(order)
                    }
                    else -> throw IllegalStateException("Invalid action $action for PENDING")
                }
            }
            OrderStatus.PAID -> {
                when (action) {
                    "ship" -> {
                        order.status = OrderStatus.SHIPPED
                        notifyShipping(order)
                    }
                    "cancel" -> {
                        order.status = OrderStatus.CANCELLED
                        refundPayment(order)
                    }
                    else -> throw IllegalStateException("Invalid action $action for PAID")
                }
            }
            OrderStatus.SHIPPED -> {
                when (action) {
                    "deliver" -> {
                        order.status = OrderStatus.DELIVERED
                        notifyDelivery(order)
                    }
                    else -> throw IllegalStateException("Invalid action $action for SHIPPED")
                }
            }
            OrderStatus.DELIVERED -> {
                throw IllegalStateException("Order already delivered")
            }
            OrderStatus.CANCELLED -> {
                throw IllegalStateException("Order is cancelled")
            }
        }
        
        return orderRepository.save(order)
    }
    
    // Ğ’ÑĞ¿Ğ¾Ğ¼Ğ¾Ğ³Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ Ğ¼ĞµÑ‚Ğ¾Ğ´Ñ‹
    private fun sendPaymentConfirmation(order: Order) { /* ... */ }
    private fun refundPayment(order: Order) { /* ... */ }
    private fun notifyShipping(order: Order) { /* ... */ }
    private fun notifyDelivery(order: Order) { /* ... */ }
}

// Ğ¥ĞĞ ĞĞ¨Ğ: State pattern
interface OrderState {
    fun pay(order: Order): Order
    fun ship(order: Order): Order
    fun deliver(order: Order): Order
    fun cancel(order: Order): Order
}

// Ğ‘Ğ°Ğ·Ğ¾Ğ²Ğ°Ñ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ñ Ğ²Ñ‹Ğ±Ñ€Ğ¾ÑĞ¾Ğ¼ Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğ¹ Ğ´Ğ»Ñ Ğ½ĞµĞ²Ğ°Ğ»Ğ¸Ğ´Ğ½Ñ‹Ñ… Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğ¹
abstract class BaseOrderState : OrderState {
    override fun pay(order: Order): Order {
        throw IllegalStateException("Cannot pay order in ${order.status} state")
    }
    
    override fun ship(order: Order): Order {
        throw IllegalStateException("Cannot ship order in ${order.status} state")
    }
    
    override fun deliver(order: Order): Order {
        throw IllegalStateException("Cannot deliver order in ${order.status} state")
    }
    
    override fun cancel(order: Order): Order {
        throw IllegalStateException("Cannot cancel order in ${order.status} state")
    }
}

@Component
class PendingOrderState(
    private val orderRepository: OrderRepository,
    private val notificationService: NotificationService
) : BaseOrderState() {
    
    override fun pay(order: Order): Order {
        order.status = OrderStatus.PAID
        order.paidAt = LocalDateTime.now()
        
        notificationService.sendPaymentConfirmation(order)
        
        return orderRepository.save(order)
    }
    
    override fun cancel(order: Order): Order {
        order.status = OrderStatus.CANCELLED
        order.cancelledAt = LocalDateTime.now()
        
        // Ğ”Ğ»Ñ PENDING Ğ½Ğµ Ğ½ÑƒĞ¶ĞµĞ½ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ Ğ´ĞµĞ½ĞµĞ³
        notificationService.sendCancellationConfirmation(order)
        
        return orderRepository.save(order)
    }
}

@Component
class PaidOrderState(
    private val orderRepository: OrderRepository,
    private val notificationService: NotificationService,
    private val paymentService: PaymentService
) : BaseOrderState() {
    
    override fun ship(order: Order): Order {
        order.status = OrderStatus.SHIPPED
        order.shippedAt = LocalDateTime.now()
        
        notificationService.sendShippingConfirmation(order)
        
        return orderRepository.save(order)
    }
    
    override fun cancel(order: Order): Order {
        order.status = OrderStatus.CANCELLED
        order.cancelledAt = LocalDateTime.now()
        
        // Ğ”Ğ»Ñ PAID Ğ½ÑƒĞ¶ĞµĞ½ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ Ğ´ĞµĞ½ĞµĞ³
        paymentService.refund(order.transactionId)
        notificationService.sendCancellationConfirmation(order)
        
        return orderRepository.save(order)
    }
}

@Component
class ShippedOrderState(
    private val orderRepository: OrderRepository,
    private val notificationService: NotificationService
) : BaseOrderState() {
    
    override fun deliver(order: Order): Order {
        order.status = OrderStatus.DELIVERED
        order.deliveredAt = LocalDateTime.now()
        
        notificationService.sendDeliveryConfirmation(order)
        
        return orderRepository.save(order)
    }
    
    // cancel() Ğ½Ğµ Ğ¿ĞµÑ€ĞµĞ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµÑ‚ÑÑ â€” Ğ½ĞµĞ»ÑŒĞ·Ñ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ·Ğ°ĞºĞ°Ğ·
}

@Component
class DeliveredOrderState : BaseOrderState() {
    // Ğ’ÑĞµ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½Ñ‹ â€” Ğ·Ğ°ĞºĞ°Ğ· ÑƒĞ¶Ğµ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ»ĞµĞ½
}

@Component
class CancelledOrderState : BaseOrderState() {
    // Ğ’ÑĞµ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½Ñ‹ â€” Ğ·Ğ°ĞºĞ°Ğ· Ğ¾Ñ‚Ğ¼ĞµĞ½Ñ‘Ğ½
}

// Ğ¤Ğ°Ğ±Ñ€Ğ¸ĞºĞ° ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğ¹
@Component
class OrderStateFactory(
    private val pendingState: PendingOrderState,
    private val paidState: PaidOrderState,
    private val shippedState: ShippedOrderState,
    private val deliveredState: DeliveredOrderState,
    private val cancelledState: CancelledOrderState
) {
    
    fun getState(status: OrderStatus): OrderState {
        return when (status) {
            OrderStatus.PENDING -> pendingState
            OrderStatus.PAID -> paidState
            OrderStatus.SHIPPED -> shippedState
            OrderStatus.DELIVERED -> deliveredState
            OrderStatus.CANCELLED -> cancelledState
        }
    }
}

@Service
class OrderProcessor(
    private val orderRepository: OrderRepository,
    private val stateFactory: OrderStateFactory
) {
    
    fun pay(orderId: Long): Order {
        val order = orderRepository.findById(orderId)
            ?: throw NotFoundException("Order not found")
        
        val state = stateFactory.getState(order.status)
        return state.pay(order)
    }
    
    fun ship(orderId: Long): Order {
        val order = orderRepository.findById(orderId)
            ?: throw NotFoundException("Order not found")
        
        val state = stateFactory.getState(order.status)
        return state.ship(order)
    }
    
    fun deliver(orderId: Long): Order {
        val order = orderRepository.findById(orderId)
            ?: throw NotFoundException("Order not found")
        
        val state = stateFactory.getState(order.status)
        return state.deliver(order)
    }
    
    fun cancel(orderId: Long): Order {
        val order = orderRepository.findById(orderId)
            ?: throw NotFoundException("Order not found")
        
        val state = stateFactory.getState(order.status)
        return state.cancel(order)
    }
}

// Ğ¢Ğ•Ğ¡Ğ¢: Ğ»ĞµĞ³ĞºĞ¾ Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¿ĞµÑ€ĞµÑ…Ğ¾Ğ´Ñ‹ Ğ¼ĞµĞ¶Ğ´Ñƒ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸ÑĞ¼Ğ¸
@Test
fun `should transition from PENDING to PAID`() {
    val order = Order(id = 1L, status = OrderStatus.PENDING)
    val state = PendingOrderState(orderRepository, notificationService)
    
    val result = state.pay(order)
    
    assertEquals(OrderStatus.PAID, result.status)
    assertNotNull(result.paidAt)
    verify { notificationService.sendPaymentConfirmation(order) }
}

@Test
fun `should not allow shipping from PENDING state`() {
    val order = Order(id = 1L, status = OrderStatus.PENDING)
    val state = PendingOrderState(orderRepository, notificationService)
    
    assertThrows<IllegalStateException> {
        state.ship(order)
    }
}

@Test
fun `should refund when cancelling PAID order`() {
    val order = Order(id = 1L, status = OrderStatus.PAID, transactionId = "tx_123")
    val state = PaidOrderState(orderRepository, notificationService, paymentService)
    
    state.cancel(order)
    
    verify { paymentService.refund("tx_123") }
}

@Test
fun `should not refund when cancelling PENDING order`() {
    val order = Order(id = 1L, status = OrderStatus.PENDING)
    val state = PendingOrderState(orderRepository, notificationService)
    
    state.cancel(order)
    
    // Ğ”Ğ»Ñ PENDING Ğ½Ğµ Ğ²Ñ‹Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ÑÑ paymentService
    verify(exactly = 0) { paymentService.refund(any()) }
}
```
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

---

## Clean Code Ğ¿Ñ€Ğ°ĞºÑ‚Ğ¸ĞºĞ¸

### ĞšĞ•Ğ™Ğ¡ #9 | Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ: Middle
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
**Ğ’ĞĞŸĞ ĞĞ¡:**
Code reviewer Ğ³Ğ¾Ğ²Ğ¾Ñ€Ğ¸Ñ‚, Ñ‡Ñ‚Ğ¾ Ğ²Ğ°ÑˆĞ° Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ `processData()` Ğ¸Ğ¼ĞµĞµÑ‚ ÑĞ»Ğ¸ÑˆĞºĞ¾Ğ¼ Ğ¼Ğ½Ğ¾Ğ³Ğ¾ ÑƒÑ€Ğ¾Ğ²Ğ½ĞµĞ¹ 
Ğ²Ğ»Ğ¾Ğ¶ĞµĞ½Ğ½Ğ¾ÑÑ‚Ğ¸ (4-5 ÑƒÑ€Ğ¾Ğ²Ğ½ĞµĞ¹ if/for). ĞšĞ°Ğº ÑƒĞ¿Ñ€Ğ¾ÑÑ‚Ğ¸Ñ‚ÑŒ Ğ¸ Ğ¿Ğ¾Ñ‡ĞµĞ¼Ñƒ ÑÑ‚Ğ¾ Ğ²Ğ°Ğ¶Ğ½Ğ¾?

**ĞĞ¢Ğ’Ğ•Ğ¢:**
Ğ“Ğ»ÑƒĞ±Ğ¾ĞºĞ°Ñ Ğ²Ğ»Ğ¾Ğ¶ĞµĞ½Ğ½Ğ¾ÑÑ‚ÑŒ ÑƒÑ…ÑƒĞ´ÑˆĞ°ĞµÑ‚ Ñ‡Ğ¸Ñ‚Ğ°ĞµĞ¼Ğ¾ÑÑ‚ÑŒ Ğ¸ ÑƒĞ²ĞµĞ»Ğ¸Ñ‡Ğ¸Ğ²Ğ°ĞµÑ‚ ĞºĞ¾Ğ³Ğ½Ğ¸Ñ‚Ğ¸Ğ²Ğ½ÑƒÑ Ğ½Ğ°Ğ³Ñ€ÑƒĞ·ĞºÑƒ. 
Ğ ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´ÑƒĞµÑ‚ÑÑ Ğ¼Ğ°ĞºÑĞ¸Ğ¼ÑƒĞ¼ 2-3 ÑƒÑ€Ğ¾Ğ²Ğ½Ñ Ğ²Ğ»Ğ¾Ğ¶ĞµĞ½Ğ½Ğ¾ÑÑ‚Ğ¸.

Ğ¢ĞµÑ…Ğ½Ğ¸ĞºĞ¸:
- Early return (guard clauses)
- Ğ˜Ğ·Ğ²Ğ»ĞµÑ‡ĞµĞ½Ğ¸Ğµ Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ¾Ğ²
- Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¹ Ğ²Ñ‹ÑÑˆĞµĞ³Ğ¾ Ğ¿Ğ¾Ñ€ÑĞ´ĞºĞ° (filter, map)
- Ğ˜Ğ½Ğ²ĞµÑ€ÑĞ¸Ñ ÑƒÑĞ»Ğ¾Ğ²Ğ¸Ğ¹

**ĞŸĞĞ§Ğ•ĞœĞ£ Ğ­Ğ¢Ğ Ğ’ĞĞ–ĞĞ:**
- Ğ§Ğ¸Ñ‚Ğ°ĞµĞ¼Ğ¾ÑÑ‚ÑŒ: ĞºĞ¾Ğ´ Ğ»ĞµĞ³Ñ‡Ğµ Ğ¿Ğ¾Ğ½ÑÑ‚ÑŒ Ñ Ğ¿ĞµÑ€Ğ²Ğ¾Ğ³Ğ¾ Ğ²Ğ·Ğ³Ğ»ÑĞ´Ğ°
- ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶ĞºĞ°: Ğ¿Ñ€Ğ¾Ñ‰Ğµ Ğ²Ğ½Ğ¾ÑĞ¸Ñ‚ÑŒ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ
- ĞœĞµĞ½ÑŒÑˆĞµ Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº: ÑĞ½Ğ¸Ğ¶Ğ°ĞµÑ‚ÑÑ Ğ²ĞµÑ€Ğ¾ÑÑ‚Ğ½Ğ¾ÑÑ‚ÑŒ Ğ»Ğ¾Ğ³Ğ¸Ñ‡ĞµÑĞºĞ¸Ñ… Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº

**ĞŸĞ Ğ˜ĞœĞ•Ğ  ĞšĞĞ”Ğ:**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```kotlin
// ĞŸĞ›ĞĞ¥Ğ: Ğ³Ğ»ÑƒĞ±Ğ¾ĞºĞ°Ñ Ğ²Ğ»Ğ¾Ğ¶ĞµĞ½Ğ½Ğ¾ÑÑ‚ÑŒ (5 ÑƒÑ€Ğ¾Ğ²Ğ½ĞµĞ¹)
fun processDataBad(users: List<User>): List<ProcessedUser> {
    val result = mutableListOf<ProcessedUser>()
    
    if (users.isNotEmpty()) {  // Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ 1
        for (user in users) {  // Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ 2
            if (user.isActive) {  // Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ 3
                if (user.age >= 18) {  // Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ 4
                    if (user.orders.isNotEmpty()) {  // Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ 5
                        val totalSpent = user.orders.sumOf { it.total }
                        if (totalSpent > 1000) {
                            result.add(
                                ProcessedUser(
                                    id = user.id,
                                    name = user.name,
                                    totalSpent = totalSpent,
                                    tier = "PREMIUM"
                                )
                            )
                        } else {
                            result.add(
                                ProcessedUser(
                                    id = user.id,
                                    name = user.name,
                                    totalSpent = totalSpent,
                                    tier = "REGULAR"
                                )
                            )
                        }
                    }
                }
            }
        }
    }
    
    return result
}

// Ğ¥ĞĞ ĞĞ¨Ğ: ÑƒĞ¼ĞµĞ½ÑŒÑˆĞµĞ½Ğ¸Ğµ Ğ²Ğ»Ğ¾Ğ¶ĞµĞ½Ğ½Ğ¾ÑÑ‚Ğ¸ Ñ‡ĞµÑ€ĞµĞ· early return Ğ¸ Ğ¸Ğ·Ğ²Ğ»ĞµÑ‡ĞµĞ½Ğ¸Ğµ Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ¾Ğ²
fun processDataGood(users: List<User>): List<ProcessedUser> {
    // Guard clause â€” Ñ€Ğ°Ğ½Ğ½Ğ¸Ğ¹ Ğ²Ñ‹Ñ…Ğ¾Ğ´
    if (users.isEmpty()) return emptyList()
    
    return users
        .filter { it.isActive }  // Ğ¤Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ Ğ²Ğ¼ĞµÑÑ‚Ğ¾ if
        .filter { it.age >= 18 }
        .filter { it.orders.isNotEmpty() }
        .map { user -> processUser(user) }  // Ğ˜Ğ·Ğ²Ğ»ĞµÑ‡ĞµĞ½Ğ¸Ğµ Ğ² Ğ¾Ñ‚Ğ´ĞµĞ»ÑŒĞ½Ñ‹Ğ¹ Ğ¼ĞµÑ‚Ğ¾Ğ´
}

private fun processUser(user: User): ProcessedUser {
    val totalSpent = calculateTotalSpent(user)
    val tier = determineTier(totalSpent)
    
    return ProcessedUser(
        id = user.id,
        name = user.name,
        totalSpent = totalSpent,
        tier = tier
    )
}

private fun calculateTotalSpent(user: User): BigDecimal {
    return user.orders.sumOf { it.total }
}

private fun determineTier(totalSpent: BigDecimal): String {
    return if (totalSpent > BigDecimal(1000)) "PREMIUM" else "REGULAR"
}

// Ğ•Ğ©Ğ Ğ›Ğ£Ğ§Ğ¨Ğ•: Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ extension functions Ğ´Ğ»Ñ Ñ‡Ğ¸Ñ‚Ğ°ĞµĞ¼Ğ¾ÑÑ‚Ğ¸
fun List<User>.filterEligible(): List<User> {
    return this
        .filter { it.isActive }
        .filter { it.age >= 18 }
        .filter { it.orders.isNotEmpty() }
}

fun User.toProcessedUser(): ProcessedUser {
    val totalSpent = orders.sumOf { it.total }
    return ProcessedUser(
        id = id,
        name = name,
        totalSpent = totalSpent,
        tier = if (totalSpent > BigDecimal(1000)) "PREMIUM" else "REGULAR"
    )
}

fun processDataBest(users: List<User>): List<ProcessedUser> {
    return users
        .filterEligible()
        .map { it.toProcessedUser() }
}

// Ğ¢Ğ•Ğ¡Ğ¢: Ğ»ĞµĞ³ĞºĞ¾ Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¾Ñ‚Ğ´ĞµĞ»ÑŒĞ½Ñ‹Ğµ Ñ‡Ğ°ÑÑ‚Ğ¸
@Test
fun `should filter only eligible users`() {
    val users = listOf(
        User(id = 1, isActive = true, age = 25, orders = listOf(testOrder)),
        User(id = 2, isActive = false, age = 25, orders = listOf(testOrder)),
        User(id = 3, isActive = true, age = 16, orders = listOf(testOrder)),
        User(id = 4, isActive = true, age = 25, orders = emptyList())
    )
    
    val eligible = users.filterEligible()
    
    assertEquals(1, eligible.size)
    assertEquals(1L, eligible[0].id)
}

@Test
fun `should determine PREMIUM tier for high spenders`() {
    val user = User(
        id = 1,
        orders = listOf(
            Order(total = BigDecimal(600)),
            Order(total = BigDecimal(500))
        )
    )
    
    val processed = user.toProcessedUser()
    
    assertEquals("PREMIUM", processed.tier)
    assertEquals(BigDecimal(1100), processed.totalSpent)
}
```
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

### ĞšĞ•Ğ™Ğ¡ #10 | Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ: Middle
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
**Ğ’ĞĞŸĞ ĞĞ¡:**
Code reviewer Ğ³Ğ¾Ğ²Ğ¾Ñ€Ğ¸Ñ‚, Ñ‡Ñ‚Ğ¾ Ğ²Ğ°ÑˆĞ¸ Ğ¼ĞµÑ‚Ğ¾Ğ´Ñ‹ Ğ¸Ğ¼ĞµÑÑ‚ ÑĞ»Ğ¸ÑˆĞºĞ¾Ğ¼ Ğ¼Ğ½Ğ¾Ğ³Ğ¾ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğ¾Ğ² (6-8 Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğ¾Ğ²). 
ĞšĞ°Ğº ÑƒĞ¿Ñ€Ğ¾ÑÑ‚Ğ¸Ñ‚ÑŒ Ğ¸ Ğ¿Ğ¾Ñ‡ĞµĞ¼Ñƒ ÑÑ‚Ğ¾ Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼Ğ°?

**ĞĞ¢Ğ’Ğ•Ğ¢:**
ĞœĞ½Ğ¾Ğ³Ğ¾ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğ¾Ğ² â€” Ğ¿Ñ€Ğ¸Ğ·Ğ½Ğ°Ğº Ñ‚Ğ¾Ğ³Ğ¾, Ñ‡Ñ‚Ğ¾ Ğ¼ĞµÑ‚Ğ¾Ğ´ Ğ´ĞµĞ»Ğ°ĞµÑ‚ ÑĞ»Ğ¸ÑˆĞºĞ¾Ğ¼ Ğ¼Ğ½Ğ¾Ğ³Ğ¾ Ğ¸Ğ»Ğ¸ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ñ‹ Ğ»Ğ¾Ğ³Ğ¸Ñ‡ĞµÑĞºĞ¸ 
ÑĞ²ÑĞ·Ğ°Ğ½Ñ‹ Ğ¸ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ñ‹ Ğ±Ñ‹Ñ‚ÑŒ ÑĞ³Ñ€ÑƒĞ¿Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ñ‹.

Ğ ĞµÑˆĞµĞ½Ğ¸Ñ:
- Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ¸Ñ€Ğ¾Ğ²ĞºĞ° Ğ² Ğ¾Ğ±ÑŠĞµĞºÑ‚ (Parameter Object pattern)
- Builder pattern Ğ´Ğ»Ñ Ğ¾Ğ¿Ñ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ñ‹Ñ… Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğ¾Ğ²
- Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ default parameters (Kotlin)

**ĞŸĞĞ§Ğ•ĞœĞ£ Ğ­Ğ¢Ğ Ğ’ĞĞ–ĞĞ:**
- Ğ§Ğ¸Ñ‚Ğ°ĞµĞ¼Ğ¾ÑÑ‚ÑŒ: Ğ»ĞµĞ³Ñ‡Ğµ Ğ¿Ğ¾Ğ½ÑÑ‚ÑŒ, Ñ‡Ñ‚Ğ¾ Ğ´ĞµĞ»Ğ°ĞµÑ‚ Ğ¼ĞµÑ‚Ğ¾Ğ´
- ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶ĞºĞ°: Ğ¿Ñ€Ğ¾Ñ‰Ğµ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑÑ‚ÑŒ Ğ½Ğ¾Ğ²Ñ‹Ğµ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ñ‹
- ĞœĞµĞ½ÑŒÑˆĞµ Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº: ÑĞ»Ğ¾Ğ¶Ğ½ĞµĞµ Ğ¿ĞµÑ€ĞµĞ¿ÑƒÑ‚Ğ°Ñ‚ÑŒ Ğ¿Ğ¾Ñ€ÑĞ´Ğ¾Ğº Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğ¾Ğ²

**ĞŸĞ Ğ˜ĞœĞ•Ğ  ĞšĞĞ”Ğ:**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```kotlin
// ĞŸĞ›ĞĞ¥Ğ: 8 Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğ¾Ğ²
fun createUserBad(
    firstName: String,
    lastName: String,
    email: String,
    phone: String,
    address: String,
    city: String,
    country: String,
    zipCode: String
): User {
    // Ğ›ĞµĞ³ĞºĞ¾ Ğ¿ĞµÑ€ĞµĞ¿ÑƒÑ‚Ğ°Ñ‚ÑŒ Ğ¿Ğ¾Ñ€ÑĞ´Ğ¾Ğº Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğ¾Ğ²!
    return User(
        firstName = firstName,
        lastName = lastName,
        email = email,
        phone = phone,
        address = address,
        city = city,
        country = country,
        zipCode = zipCode
    )
}

// Ğ’Ñ‹Ğ·Ğ¾Ğ² â€” ÑĞ»Ğ¾Ğ¶Ğ½Ğ¾ Ñ‡Ğ¸Ñ‚Ğ°Ñ‚ÑŒ
val user = createUserBad(
    "John",
    "Doe",
    "john@example.com",
    "+1234567890",
    "123 Main St",
    "New York",
    "USA",
    "10001"
)

// Ğ¥ĞĞ ĞĞ¨Ğ: Ğ³Ñ€ÑƒĞ¿Ğ¿Ğ¸Ñ€Ğ¾Ğ²ĞºĞ° Ğ² Ğ¾Ğ±ÑŠĞµĞºÑ‚ (Parameter Object)
data class UserRegistrationData(
    val personalInfo: PersonalInfo,
    val contactInfo: ContactInfo,
    val addressInfo: AddressInfo
)

data class PersonalInfo(
    val firstName: String,
    val lastName: String
)

data class ContactInfo(
    val email: String,
    val phone: String
)

data class AddressInfo(
    val address: String,
    val city: String,
    val country: String,
    val zipCode: String
)

fun createUserGood(data: UserRegistrationData): User {
    return User(
        firstName = data.personalInfo.firstName,
        lastName = data.personalInfo.lastName,
        email = data.contactInfo.email,
        phone = data.contactInfo.phone,
        address = data.addressInfo.address,
        city = data.addressInfo.city,
        country = data.addressInfo.country,
        zipCode = data.addressInfo.zipCode
    )
}

// Ğ’Ñ‹Ğ·Ğ¾Ğ² â€” ÑĞ²Ğ½Ğ¾ Ğ²Ğ¸Ğ´Ğ½Ñ‹ Ğ³Ñ€ÑƒĞ¿Ğ¿Ñ‹ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğ¾Ğ²
val user = createUserGood(
    UserRegistrationData(
        personalInfo = PersonalInfo(
            firstName = "John",
            lastName = "Doe"
        ),
        contactInfo = ContactInfo(
            email = "john@example.com",
            phone = "+1234567890"
        ),
        addressInfo = AddressInfo(
            address = "123 Main St",
            city = "New York",
            country = "USA",
            zipCode = "10001"
        )
    )
)

// ĞĞ›Ğ¬Ğ¢Ğ•Ğ ĞĞĞ¢Ğ˜Ğ’Ğ: Builder pattern Ğ´Ğ»Ñ ÑĞ»Ğ¾Ğ¶Ğ½Ñ‹Ñ… Ğ¾Ğ±ÑŠĞµĞºÑ‚Ğ¾Ğ² Ñ Ğ¾Ğ¿Ñ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¼Ğ¸ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğ°Ğ¼Ğ¸
class UserBuilder {
    private var firstName: String = ""
    private var lastName: String = ""
    private var email: String = ""
    private var phone: String? = null
    private var address: String? = null
    private var city: String? = null
    private var country: String? = null
    private var zipCode: String? = null
    
    fun firstName(value: String) = apply { firstName = value }
    fun lastName(value: String) = apply { lastName = value }
    fun email(value: String) = apply { email = value }
    fun phone(value: String) = apply { phone = value }
    fun address(value: String) = apply { address = value }
    fun city(value: String) = apply { city = value }
    fun country(value: String) = apply { country = value }
    fun zipCode(value: String) = apply { zipCode = value }
    
    fun build(): User {
        require(firstName.isNotBlank()) { "First name is required" }
        require(lastName.isNotBlank()) { "Last name is required" }
        require(email.isNotBlank()) { "Email is required" }
        
        return User(
            firstName = firstName,
            lastName = lastName,
            email = email,
            phone = phone,
            address = address,
            city = city,
            country = country,
            zipCode = zipCode
        )
    }
}

// Ğ’Ñ‹Ğ·Ğ¾Ğ² â€” Ñ‡Ğ¸Ñ‚Ğ°ĞµĞ¼Ğ¾ Ğ¸ Ğ³Ğ¸Ğ±ĞºĞ¾
val user = UserBuilder()
    .firstName("John")
    .lastName("Doe")
    .email("john@example.com")
    .phone("+1234567890")
    .address("123 Main St")
    .city("New York")
    .country("USA")
    .zipCode("10001")
    .build()

// KOTLIN Ğ¡ĞŸĞĞ¡ĞĞ‘: default parameters + named arguments
data class User(
    val firstName: String,
    val lastName: String,
    val email: String,
    val phone: String? = null,
    val address: String? = null,
    val city: String? = null,
    val country: String? = null,
    val zipCode: String? = null
)

// Ğ’Ñ‹Ğ·Ğ¾Ğ² â€” ĞºĞ¾Ğ¼Ğ¿Ğ°ĞºÑ‚Ğ½Ğ¾ Ğ¸ Ğ¿Ğ¾Ğ½ÑÑ‚Ğ½Ğ¾
val user = User(
    firstName = "John",
    lastName = "Doe",
    email = "john@example.com",
    phone = "+1234567890",
    city = "New York",
    country = "USA"
)

// Ğ¢Ğ•Ğ¡Ğ¢: Ğ³Ñ€ÑƒĞ¿Ğ¿Ğ¸Ñ€Ğ¾Ğ²ĞºĞ° ÑƒĞ¿Ñ€Ğ¾Ñ‰Ğ°ĞµÑ‚ Ğ¼Ğ¾ĞºĞ¸
@Test
fun `should create user with valid data`() {
    val data = UserRegistrationData(
        personalInfo = PersonalInfo("John", "Doe"),
        contactInfo = ContactInfo("john@example.com", "+1234567890"),
        addressInfo = AddressInfo("123 Main St", "NY", "USA", "10001")
    )
    
    val user = createUserGood(data)
    
    assertEquals("John", user.firstName)
    assertEquals("john@example.com", user.email)
}
```
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

---

## Ğ ĞµÑ„Ğ°ĞºÑ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³

### ĞšĞ•Ğ™Ğ¡ #11 | Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ: Middle
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
**Ğ’ĞĞŸĞ ĞĞ¡:**
Ğ£ Ğ²Ğ°Ñ ĞµÑÑ‚ÑŒ Ğ¼ĞµÑ‚Ğ¾Ğ´ Ñ 5 Ğ±ÑƒĞ»ĞµĞ²Ñ‹Ğ¼Ğ¸ Ñ„Ğ»Ğ°Ğ³Ğ°Ğ¼Ğ¸. Code reviewer Ğ¿Ñ€ĞµĞ´Ğ»Ğ°Ğ³Ğ°ĞµÑ‚ Ğ·Ğ°Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ½Ğ° Enum 
Ğ¸Ğ»Ğ¸ Strategy. ĞŸĞ¾Ñ‡ĞµĞ¼Ñƒ Ñ„Ğ»Ğ°Ğ³Ğ¸ â€” ÑÑ‚Ğ¾ Ğ¿Ğ»Ğ¾Ñ…Ğ¾?

**ĞĞ¢Ğ’Ğ•Ğ¢:**
Ğ‘ÑƒĞ»ĞµĞ²Ñ‹ Ñ„Ğ»Ğ°Ğ³Ğ¸ ÑĞ¾Ğ·Ğ´Ğ°ÑÑ‚ **ĞºĞ¾Ğ¼Ğ±Ğ¸Ğ½Ğ°Ñ‚Ğ¾Ñ€Ğ½Ñ‹Ğ¹ Ğ²Ğ·Ñ€Ñ‹Ğ²**: 5 Ñ„Ğ»Ğ°Ğ³Ğ¾Ğ² = 32 Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ñ‹Ñ… ĞºĞ¾Ğ¼Ğ±Ğ¸Ğ½Ğ°Ñ†Ğ¸Ğ¸.
ĞœĞ½Ğ¾Ğ³Ğ¸Ğµ ĞºĞ¾Ğ¼Ğ±Ğ¸Ğ½Ğ°Ñ†Ğ¸Ğ¸ Ğ±ĞµÑÑĞ¼Ñ‹ÑĞ»ĞµĞ½Ğ½Ñ‹, Ğ½Ğ¾ ĞºĞ¾Ğ¼Ğ¿Ğ¸Ğ»ÑÑ‚Ğ¾Ñ€ Ğ½Ğµ Ğ¿Ğ¾Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ¸Ñ… Ğ¾Ñ‚Ğ»Ğ¾Ğ²Ğ¸Ñ‚ÑŒ.

**ĞŸĞ Ğ˜ĞœĞ•Ğ  ĞšĞĞ”Ğ:**
```kotlin
// ĞŸĞ›ĞĞ¥Ğ: boolean hell
fun processPayment(
    amount: BigDecimal,
    isUrgent: Boolean,
    shouldSendEmail: Boolean,
    requiresApproval: Boolean,
    isInternational: Boolean,
    applyDiscount: Boolean
) {
    if (isUrgent && requiresApproval) {
        // ĞšĞ¾Ğ½Ñ„Ğ»Ğ¸ĞºÑ‚ÑƒÑÑ‰Ğ°Ñ Ğ»Ğ¾Ğ³Ğ¸ĞºĞ°
    }
    // ...
}

// ĞšĞ°Ğº Ğ²Ñ‹Ğ·Ñ‹Ğ²Ğ°Ñ‚ÑŒ? ĞŸĞ¾Ñ€ÑĞ´Ğ¾Ğº Ğ»ĞµĞ³ĞºĞ¾ Ğ¿ĞµÑ€ĞµĞ¿ÑƒÑ‚Ğ°Ñ‚ÑŒ
processPayment(100.0, true, false, true, false, true)  // Ğ§Ñ‚Ğ¾ ÑÑ‚Ğ¾ Ğ·Ğ½Ğ°Ñ‡Ğ¸Ñ‚?

// Ğ¥ĞĞ ĞĞ¨Ğ: Enum Ğ´Ğ»Ñ Ñ‚Ğ¸Ğ¿Ğ° Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶Ğ°
enum class PaymentType {
    STANDARD,
    URGENT,
    INTERNATIONAL_STANDARD,
    INTERNATIONAL_URGENT
}

data class PaymentOptions(
    val type: PaymentType,
    val sendNotification: Boolean = true,
    val applyDiscount: Boolean = false
)

fun processPayment(amount: BigDecimal, options: PaymentOptions) {
    when (options.type) {
        PaymentType.URGENT -> processUrgent(amount, options)
        PaymentType.INTERNATIONAL_URGENT -> processInternationalUrgent(amount, options)
        else -> processStandard(amount, options)
    }
}

// Ğ’Ñ‹Ğ·Ğ¾Ğ² â€” Ğ¿Ğ¾Ğ½ÑÑ‚Ğ½Ğ¾ Ñ‡Ñ‚Ğ¾ Ğ¿Ñ€Ğ¾Ğ¸ÑÑ…Ğ¾Ğ´Ğ¸Ñ‚
processPayment(
    BigDecimal("100.00"),
    PaymentOptions(
        type = PaymentType.URGENT,
        sendNotification = true,
        applyDiscount = false
    )
)
```

### ĞšĞ•Ğ™Ğ¡ #12 | Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ: Senior
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
**Ğ’ĞĞŸĞ ĞĞ¡:**
ĞšĞ°Ğº Ğ¸Ğ·Ğ²Ğ»ĞµÑ‡ÑŒ God Object (ĞºĞ»Ğ°ÑÑ Ğ½Ğ° 2000 ÑÑ‚Ñ€Ğ¾Ğº Ñ 50 Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ°Ğ¼Ğ¸) Ğ² Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¾ ĞºĞ»Ğ°ÑÑĞ¾Ğ²?
Ğ¡ Ñ‡ĞµĞ³Ğ¾ Ğ½Ğ°Ñ‡Ğ°Ñ‚ÑŒ Ñ€ĞµÑ„Ğ°ĞºÑ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³?

**ĞĞ¢Ğ’Ğ•Ğ¢:**
**Ğ¡Ñ‚Ñ€Ğ°Ñ‚ĞµĞ³Ğ¸Ñ Ñ€ĞµÑ„Ğ°ĞºÑ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³Ğ° God Object:**
1. ĞĞ°Ğ¹Ñ‚Ğ¸ Ğ³Ñ€ÑƒĞ¿Ğ¿Ñ‹ ÑĞ²ÑĞ·Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ¾Ğ² (Feature Envy)
2. Ğ˜Ğ·Ğ²Ğ»ĞµÑ‡ÑŒ Ğ² Ğ¾Ñ‚Ğ´ĞµĞ»ÑŒĞ½Ñ‹Ğµ ĞºĞ»Ğ°ÑÑÑ‹
3. ĞŸÑ€Ğ¸Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Facade Ğ´Ğ»Ñ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ Ğ¾Ğ±Ñ€Ğ°Ñ‚Ğ½Ğ¾Ğ¹ ÑĞ¾Ğ²Ğ¼ĞµÑÑ‚Ğ¸Ğ¼Ğ¾ÑÑ‚Ğ¸

**ĞŸĞ Ğ˜ĞœĞ•Ğ  ĞšĞĞ”Ğ:**
```kotlin
// ĞŸĞ›ĞĞ¥Ğ: God Object (2000 ÑÑ‚Ñ€Ğ¾Ğº)
@Service
class UserService {
    // === Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑĞ¼Ğ¸ (200 ÑÑ‚Ñ€Ğ¾Ğº) ===
    fun createUser() { }
    fun updateUser() { }
    fun deleteUser() { }
    fun findUser() { }
    
    // === ĞÑƒÑ‚ĞµĞ½Ñ‚Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ (300 ÑÑ‚Ñ€Ğ¾Ğº) ===
    fun login() { }
    fun logout() { }
    fun resetPassword() { }
    fun verifyToken() { }
    
    // === Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ (250 ÑÑ‚Ñ€Ğ¾Ğº) ===
    fun sendWelcomeEmail() { }
    fun sendPasswordResetEmail() { }
    fun sendNotification() { }
    
    // === Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° (200 ÑÑ‚Ñ€Ğ¾Ğº) ===
    fun getUserStats() { }
    fun getActivityReport() { }
    fun calculateMetrics() { }
    
    // === Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ (150 ÑÑ‚Ñ€Ğ¾Ğº) ===
    fun validateEmail() { }
    fun validatePassword() { }
    fun validateProfile() { }
    
    // ... ĞµÑ‰Ñ‘ 1000 ÑÑ‚Ñ€Ğ¾Ğº
}

// Ğ¥ĞĞ ĞĞ¨Ğ: Ñ€Ğ°Ğ·Ğ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ğ½Ğ° ÑĞµÑ€Ğ²Ğ¸ÑÑ‹
@Service
class UserManagementService(
    private val userRepository: UserRepository
) {
    fun createUser(userDto: UserDto): User = userRepository.save(userDto.toEntity())
    fun updateUser(id: Long, userDto: UserDto): User { /* ... */ }
    fun deleteUser(id: Long) = userRepository.deleteById(id)
    fun findUser(id: Long): User? = userRepository.findById(id).orElse(null)
}

@Service
class UserAuthenticationService(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
    private val jwtService: JwtService
) {
    fun login(email: String, password: String): AuthToken { /* ... */ }
    fun logout(token: String) { /* ... */ }
    fun resetPassword(email: String) { /* ... */ }
    fun verifyToken(token: String): Boolean { /* ... */ }
}

@Service
class UserNotificationService(
    private val emailService: EmailService
) {
    fun sendWelcomeEmail(user: User) { /* ... */ }
    fun sendPasswordResetEmail(user: User, resetToken: String) { /* ... */ }
    fun sendNotification(user: User, message: String) { /* ... */ }
}

@Service
class UserStatisticsService(
    private val userRepository: UserRepository,
    private val activityRepository: ActivityRepository
) {
    fun getUserStats(userId: Long): UserStats { /* ... */ }
    fun getActivityReport(userId: Long): ActivityReport { /* ... */ }
    fun calculateMetrics(): Metrics { /* ... */ }
}

// Facade Ğ´Ğ»Ñ Ğ¾Ğ±Ñ€Ğ°Ñ‚Ğ½Ğ¾Ğ¹ ÑĞ¾Ğ²Ğ¼ĞµÑÑ‚Ğ¸Ğ¼Ğ¾ÑÑ‚Ğ¸
@Service
class UserFacade(
    private val management: UserManagementService,
    private val auth: UserAuthenticationService,
    private val notifications: UserNotificationService,
    private val statistics: UserStatisticsService
) {
    fun createUser(userDto: UserDto): User {
        val user = management.createUser(userDto)
        notifications.sendWelcomeEmail(user)
        return user
    }
    
    fun login(email: String, password: String): AuthToken =
        auth.login(email, password)
    
    // Ğ”ĞµĞ»ĞµĞ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğº ÑĞ¿ĞµÑ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¼ ÑĞµÑ€Ğ²Ğ¸ÑĞ°Ğ¼
}
```

### ĞšĞ•Ğ™Ğ¡ #13 | Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ: Middle
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
**Ğ’ĞĞŸĞ ĞĞ¡:**
Ğ£ Ğ²Ğ°Ñ ĞµÑÑ‚ÑŒ Ğ´ÑƒĞ±Ğ»Ğ¸Ñ€ÑƒÑÑ‰Ğ¸Ğ¹ÑÑ ĞºĞ¾Ğ´ Ğ² 5 Ğ¼ĞµÑÑ‚Ğ°Ñ…. ĞšĞ°Ğº Ğ¿Ñ€Ğ¸Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ DRY (Don't Repeat Yourself)
Ğ½Ğµ ÑĞ¾Ğ·Ğ´Ğ°Ğ²Ğ°Ñ Ğ¸Ğ·Ğ»Ğ¸ÑˆĞ½ÑÑ Ğ°Ğ±ÑÑ‚Ñ€Ğ°ĞºÑ†Ğ¸Ñ?

**ĞĞ¢Ğ’Ğ•Ğ¢:**
**ĞŸÑ€Ğ°Ğ²Ğ¸Ğ»Ğ¾ Ñ‚Ñ€Ñ‘Ñ…**: Ğ´ÑƒĞ±Ğ»Ğ¸Ñ€ÑƒĞ¹Ñ‚Ğµ Ğ´Ğ²Ğ°Ğ¶Ğ´Ñ‹, Ğ°Ğ±ÑÑ‚Ñ€Ğ°Ğ³Ğ¸Ñ€ÑƒĞ¹Ñ‚Ğµ Ğ½Ğ° Ñ‚Ñ€ĞµÑ‚Ğ¸Ğ¹ Ñ€Ğ°Ğ·.
Ğ˜Ğ·Ğ±ĞµĞ³Ğ°Ğ¹Ñ‚Ğµ Ğ¿Ñ€ĞµĞ¶Ğ´ĞµĞ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾Ğ¹ Ğ°Ğ±ÑÑ‚Ñ€Ğ°ĞºÑ†Ğ¸Ğ¸ â€” Ğ¾Ğ½Ğ° Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ±Ñ‹Ñ‚ÑŒ Ñ…ÑƒĞ¶Ğµ Ğ´ÑƒĞ±Ğ»Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ.

**ĞŸĞ Ğ˜ĞœĞ•Ğ  ĞšĞĞ”Ğ:**
```kotlin
// Ğ”ÑƒĞ±Ğ»Ğ¸ĞºĞ°Ñ‚ Ğ² 5 Ğ¼ĞµÑÑ‚Ğ°Ñ…
fun processOrder() {
    logger.info("Starting order processing")
    val startTime = System.currentTimeMillis()
    try {
        // Ğ‘Ğ¸Ğ·Ğ½ĞµÑ-Ğ»Ğ¾Ğ³Ğ¸ĞºĞ°
    } catch (e: Exception) {
        logger.error("Order processing failed", e)
        throw e
    } finally {
        val duration = System.currentTimeMillis() - startTime
        logger.info("Order processing completed in ${duration}ms")
    }
}

fun processPayment() {
    logger.info("Starting payment processing")
    val startTime = System.currentTimeMillis()
    try {
        // Ğ‘Ğ¸Ğ·Ğ½ĞµÑ-Ğ»Ğ¾Ğ³Ğ¸ĞºĞ°
    } catch (e: Exception) {
        logger.error("Payment processing failed", e)
        throw e
    } finally {
        val duration = System.currentTimeMillis() - startTime
        logger.info("Payment processing completed in ${duration}ms")
    }
}

// Ğ¥ĞĞ ĞĞ¨Ğ: Ğ¸Ğ·Ğ²Ğ»ĞµÑ‡ĞµĞ½Ğ¸Ğµ Ğ¾Ğ±Ñ‰ĞµĞ¹ Ğ»Ğ¾Ğ³Ğ¸ĞºĞ¸
inline fun <T> measureAndLog(
    operation: String,
    block: () -> T
): T {
    logger.info("Starting $operation")
    val startTime = System.currentTimeMillis()
    
    return try {
        block()
    } catch (e: Exception) {
        logger.error("$operation failed", e)
        throw e
    } finally {
        val duration = System.currentTimeMillis() - startTime
        logger.info("$operation completed in ${duration}ms")
    }
}

// Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ
fun processOrder() = measureAndLog("order processing") {
    // Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ±Ğ¸Ğ·Ğ½ĞµÑ-Ğ»Ğ¾Ğ³Ğ¸ĞºĞ°
    orderRepository.save(order)
}

fun processPayment() = measureAndLog("payment processing") {
    // Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ±Ğ¸Ğ·Ğ½ĞµÑ-Ğ»Ğ¾Ğ³Ğ¸ĞºĞ°
    paymentGateway.charge(amount)
}

// Ğ˜Ğ»Ğ¸ Ñ‡ĞµÑ€ĞµĞ· Ğ°Ğ½Ğ½Ğ¾Ñ‚Ğ°Ñ†Ğ¸Ñ + AOP
@Target(AnnotationTarget.FUNCTION)
annotation class Measured

@Aspect
@Component
class MeasurementAspect {
    @Around("@annotation(Measured)")
    fun measure(joinPoint: ProceedingJoinPoint): Any? {
        val name = joinPoint.signature.name
        logger.info("Starting $name")
        val start = System.currentTimeMillis()
        
        return try {
            joinPoint.proceed()
        } finally {
            val duration = System.currentTimeMillis() - start
            logger.info("$name completed in ${duration}ms")
        }
    }
}

@Service
class OrderService {
    @Measured
    fun processOrder() {
        // Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ±Ğ¸Ğ·Ğ½ĞµÑ-Ğ»Ğ¾Ğ³Ğ¸ĞºĞ°
    }
}
```

---

## Ğ¢Ğ¸Ğ¿Ğ¸Ñ‡Ğ½Ñ‹Ğµ Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼Ñ‹ Ğ¸ Ğ°Ğ½Ñ‚Ğ¸Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½Ñ‹

### ĞšĞ•Ğ™Ğ¡ #21 | Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ: Middle
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
**Ğ’ĞĞŸĞ ĞĞ¡:**
Code reviewer Ğ³Ğ¾Ğ²Ğ¾Ñ€Ğ¸Ñ‚, Ñ‡Ñ‚Ğ¾ Ğ²Ğ°Ñˆ ĞºĞ¾Ğ´ Â«Ğ·Ğ°Ñ‰Ğ¸Ñ‚Ğ½Ğ¾Ğµ Ğ¿Ñ€Ğ¾Ğ³Ñ€Ğ°Ğ¼Ğ¼Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸ĞµÂ» â€” Ğ°Ğ½Ñ‚Ğ¸Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½.
Ğ§Ñ‚Ğ¾ Ğ½Ğµ Ñ‚Ğ°Ğº Ñ Ğ¼Ğ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²Ğ¾Ğ¼ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€Ğ¾Ğº Ğ½Ğ° null?

**ĞĞ¢Ğ’Ğ•Ğ¢:**
**Defensive Programming** Ñ…Ğ¾Ñ€Ğ¾Ñˆ, Ğ½Ğ¾ **Ğ¸Ğ·Ğ±Ñ‹Ñ‚Ğ¾Ñ‡Ğ½Ñ‹Ğµ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸** â€” Ğ°Ğ½Ñ‚Ğ¸Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½.
Ğ•ÑĞ»Ğ¸ Ğ¼ĞµÑ‚Ğ¾Ğ´ Ğ½Ğµ Ğ¿Ñ€Ğ¸Ğ½Ğ¸Ğ¼Ğ°ĞµÑ‚ null â€” Ğ½Ğµ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞ¹Ñ‚Ğµ Ğ½Ğ° null Ğ²Ğ½ÑƒÑ‚Ñ€Ğ¸.

**ĞŸĞ Ğ˜ĞœĞ•Ğ  ĞšĞĞ”Ğ:**
```kotlin
// ĞŸĞ›ĞĞ¥Ğ: Ğ¸Ğ·Ğ±Ñ‹Ñ‚Ğ¾Ñ‡Ğ½Ñ‹Ğµ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸
fun calculateDiscount(user: User, order: Order): BigDecimal {
    if (user == null) return BigDecimal.ZERO  // User Ğ½Ğµ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ±Ñ‹Ñ‚ÑŒ null!
    if (order == null) return BigDecimal.ZERO  // Order Ğ½Ğµ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ±Ñ‹Ñ‚ÑŒ null!
    
    if (user.id == null) return BigDecimal.ZERO  // Ğ’ÑĞµĞ³Ğ´Ğ° ĞµÑÑ‚ÑŒ Ğ¿Ğ¾ÑĞ»Ğµ save()
    if (order.total == null) return BigDecimal.ZERO  // total Ğ½Ğµ nullable
    
    // Ğ ĞµĞ°Ğ»ÑŒĞ½Ğ°Ñ Ğ»Ğ¾Ğ³Ğ¸ĞºĞ°
    return if (user.isPremium) {
        order.total * BigDecimal("0.1")
    } else {
        BigDecimal.ZERO
    }
}

// Ğ¥ĞĞ ĞĞ¨Ğ: ĞºĞ¾Ğ½Ñ‚Ñ€Ğ°ĞºÑ‚ Ñ‡ĞµÑ€ĞµĞ· Ñ‚Ğ¸Ğ¿Ñ‹
fun calculateDiscount(user: User, order: Order): BigDecimal {
    // ĞšĞ¾Ğ¼Ğ¿Ğ¸Ğ»ÑÑ‚Ğ¾Ñ€ Ğ³Ğ°Ñ€Ğ°Ğ½Ñ‚Ğ¸Ñ€ÑƒĞµÑ‚, Ñ‡Ñ‚Ğ¾ user Ğ¸ order Ğ½Ğµ null
    return if (user.isPremium) {
        order.total * BigDecimal("0.1")
    } else {
        BigDecimal.ZERO
    }
}

// Ğ•ÑĞ»Ğ¸ Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶ĞµĞ½ null â€” ÑĞ²Ğ½Ğ¾ Ğ² ÑĞ¸Ğ³Ğ½Ğ°Ñ‚ÑƒÑ€Ğµ
fun calculateDiscountSafe(user: User?, order: Order?): BigDecimal {
    if (user == null || order == null) return BigDecimal.ZERO
    
    return calculateDiscount(user, order)  // Ğ’Ğ½ÑƒÑ‚Ñ€Ğ¸ ÑƒĞ¶Ğµ Ğ½Ğµ null
}

// Validation Ğ½Ğ° Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ†Ğµ ÑĞ¸ÑÑ‚ĞµĞ¼Ñ‹ (Controller)
@RestController
class OrderController(private val orderService: OrderService) {
    
    @PostMapping("/orders/{id}/discount")
    fun calculateDiscount(
        @PathVariable id: Long,
        @RequestBody @Valid request: DiscountRequest
    ): DiscountResponse {
        // Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ Ğ·Ğ´ĞµÑÑŒ
        val user = userService.findById(request.userId)
            ?: throw NotFoundException("User not found")
        val order = orderService.findById(id)
            ?: throw NotFoundException("Order not found")
        
        // ĞŸĞµÑ€ĞµĞ´Ğ°Ñ‘Ğ¼ Ğ³Ğ°Ñ€Ğ°Ğ½Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ¾ Ğ½Ğµ-null Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ
        val discount = orderService.calculateDiscount(user, order)
        
        return DiscountResponse(discount)
    }
}
```

### ĞšĞ•Ğ™Ğ¡ #22 | Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ: Senior
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
**Ğ’ĞĞŸĞ ĞĞ¡:**
Ğ§Ñ‚Ğ¾ Ñ‚Ğ°ĞºĞ¾Ğµ Anemic Domain Model Ğ¸ Ğ¿Ğ¾Ñ‡ĞµĞ¼Ñƒ ÑÑ‚Ğ¾ Ğ°Ğ½Ñ‚Ğ¸Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½? ĞšĞ°Ğº Ğ¸ÑĞ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ?

**ĞĞ¢Ğ’Ğ•Ğ¢:**
**Anemic Domain Model**: Ğ¾Ğ±ÑŠĞµĞºÑ‚Ñ‹ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ñ Ğ³ĞµÑ‚Ñ‚ĞµÑ€Ğ°Ğ¼Ğ¸/ÑĞµÑ‚Ñ‚ĞµÑ€Ğ°Ğ¼Ğ¸ Ğ±ĞµĞ· Ğ¿Ğ¾Ğ²ĞµĞ´ĞµĞ½Ğ¸Ñ.
Ğ’ÑÑ Ğ»Ğ¾Ğ³Ğ¸ĞºĞ° Ğ² ÑĞµÑ€Ğ²Ğ¸ÑĞ°Ñ… â†’ Ğ¾Ğ±ÑŠĞµĞºÑ‚Ğ½Ğ¾-Ğ¾Ñ€Ğ¸ĞµĞ½Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ ĞºĞ¾Ğ´ Ğ¿Ñ€ĞµĞ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ÑÑ Ğ² Ğ¿Ñ€Ğ¾Ñ†ĞµĞ´ÑƒÑ€Ğ½Ñ‹Ğ¹.

**ĞŸĞ Ğ˜ĞœĞ•Ğ  ĞšĞĞ”Ğ:**
```kotlin
// ĞŸĞ›ĞĞ¥Ğ: Anemic Domain Model
data class Order(
    var id: Long? = null,
    var userId: Long,
    var items: MutableList<OrderItem> = mutableListOf(),
    var total: BigDecimal = BigDecimal.ZERO,
    var status: OrderStatus = OrderStatus.PENDING,
    var discount: BigDecimal = BigDecimal.ZERO
)

// Ğ’ÑÑ Ğ»Ğ¾Ğ³Ğ¸ĞºĞ° Ğ² ÑĞµÑ€Ğ²Ğ¸ÑĞµ
@Service
class OrderService {
    fun addItem(order: Order, item: OrderItem) {
        order.items.add(item)
        order.total = order.items.sumOf { it.price * it.quantity.toBigDecimal() }
    }
    
    fun applyDiscount(order: Order, discount: BigDecimal) {
        order.discount = discount
        order.total = order.total - discount
    }
    
    fun complete(order: Order) {
        if (order.items.isEmpty()) {
            throw IllegalStateException("Cannot complete empty order")
        }
        if (order.total < BigDecimal.ZERO) {
            throw IllegalStateException("Total cannot be negative")
        }
        order.status = OrderStatus.COMPLETED
    }
}

// Ğ¥ĞĞ ĞĞ¨Ğ: Rich Domain Model
class Order private constructor(
    val id: Long? = null,
    val userId: Long,
    private val _items: MutableList<OrderItem> = mutableListOf()
) {
    val items: List<OrderItem> get() = _items.toList()
    
    var status: OrderStatus = OrderStatus.PENDING
        private set
    
    var discount: BigDecimal = BigDecimal.ZERO
        private set
    
    val total: BigDecimal
        get() = calculateTotal() - discount
    
    // Ğ‘Ğ¸Ğ·Ğ½ĞµÑ-Ğ»Ğ¾Ğ³Ğ¸ĞºĞ° Ğ’ĞĞ£Ğ¢Ğ Ğ˜ Ğ¼Ğ¾Ğ´ĞµĞ»Ğ¸
    fun addItem(item: OrderItem) {
        if (status != OrderStatus.PENDING) {
            throw IllegalStateException("Cannot modify completed order")
        }
        _items.add(item)
    }
    
    fun applyDiscount(discount: BigDecimal) {
        require(discount >= BigDecimal.ZERO) { "Discount cannot be negative" }
        require(discount <= calculateTotal()) { "Discount cannot exceed total" }
        this.discount = discount
    }
    
    fun complete() {
        require(_items.isNotEmpty()) { "Cannot complete empty order" }
        require(total >= BigDecimal.ZERO) { "Total cannot be negative" }
        
        status = OrderStatus.COMPLETED
    }
    
    private fun calculateTotal(): BigDecimal {
        return _items.sumOf { it.price * it.quantity.toBigDecimal() }
    }
    
    companion object {
        fun create(userId: Long, items: List<OrderItem>): Order {
            val order = Order(userId = userId)
            items.forEach { order.addItem(it) }
            return order
        }
    }
}

// Ğ¡ĞµÑ€Ğ²Ğ¸Ñ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ĞºĞ¾Ğ¾Ñ€Ğ´Ğ¸Ğ½Ğ¸Ñ€ÑƒĞµÑ‚
@Service
class OrderService(private val orderRepository: OrderRepository) {
    
    @Transactional
    fun createOrder(userId: Long, items: List<OrderItem>): Order {
        val order = Order.create(userId, items)
        return orderRepository.save(order)
    }
    
    @Transactional
    fun completeOrder(orderId: Long) {
        val order = orderRepository.findById(orderId)
            ?: throw NotFoundException("Order not found")
        
        order.complete()  // Ğ›Ğ¾Ğ³Ğ¸ĞºĞ° Ğ²Ğ½ÑƒÑ‚Ñ€Ğ¸ Ğ¼Ğ¾Ğ´ĞµĞ»Ğ¸!
        orderRepository.save(order)
    }
}
```

### ĞšĞ•Ğ™Ğ¡ #23 | Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ: Middle
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
**Ğ’ĞĞŸĞ ĞĞ¡:**
Ğ§Ñ‚Ğ¾ Ñ‚Ğ°ĞºĞ¾Ğµ Magic Numbers Ğ¸ Magic Strings? ĞŸĞ¾Ñ‡ĞµĞ¼Ñƒ Ğ¾Ğ½Ğ¸ Ğ¿Ğ»Ğ¾Ñ…Ğ¸ Ğ¸ ĞºĞ°Ğº Ğ¸Ñ… ÑƒÑÑ‚Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ?

**ĞĞ¢Ğ’Ğ•Ğ¢:**
**Magic Numbers/Strings**: Ñ…Ğ°Ñ€Ğ´ĞºĞ¾Ğ¶ĞµĞ½Ğ½Ñ‹Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ Ğ±ĞµĞ· Ğ¾Ğ±ÑŠÑÑĞ½ĞµĞ½Ğ¸Ñ Ğ¸Ñ… ÑĞ¼Ñ‹ÑĞ»Ğ°.
ĞŸÑ€Ğ¾Ğ±Ğ»ĞµĞ¼Ñ‹: Ğ½ĞµĞ¿Ğ¾Ğ½ÑÑ‚Ğ½Ğ¾ Ñ‡Ñ‚Ğ¾ Ğ·Ğ½Ğ°Ñ‡Ğ°Ñ‚, ÑĞ»Ğ¾Ğ¶Ğ½Ğ¾ Ğ¸Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ, Ğ»ĞµĞ³ĞºĞ¾ Ğ¾ÑˆĞ¸Ğ±Ğ¸Ñ‚ÑŒÑÑ.

**ĞŸĞ Ğ˜ĞœĞ•Ğ  ĞšĞĞ”Ğ:**
```kotlin
// ĞŸĞ›ĞĞ¥Ğ: Magic Numbers Ğ¸ Strings
fun processPayment(amount: BigDecimal): PaymentResult {
    if (amount < BigDecimal("10.00")) {  // Ğ§Ñ‚Ğ¾ ÑÑ‚Ğ¾?
        throw IllegalArgumentException("Amount too small")
    }
    if (amount > BigDecimal("10000.00")) {  // ĞÑ‚ĞºÑƒĞ´Ğ° ÑÑ‚Ğ¾ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ?
        throw IllegalArgumentException("Amount too large")
    }
    
    val fee = amount * BigDecimal("0.03")  // ĞŸĞ¾Ñ‡ĞµĞ¼Ñƒ 3%?
    
    val status = paymentGateway.charge(amount + fee)
    
    return when (status) {
        "SUCCESS" -> PaymentResult.Success  // ĞĞ¿ĞµÑ‡Ğ°Ñ‚ĞºĞ° = Ğ±Ğ°Ğ³
        "FAILED" -> PaymentResult.Failed
        "PENDING" -> PaymentResult.Pending
        else -> PaymentResult.Unknown
    }
}

// Ğ¥ĞĞ ĞĞ¨Ğ: ĞºĞ¾Ğ½ÑÑ‚Ğ°Ğ½Ñ‚Ñ‹ Ñ Ğ³Ğ¾Ğ²Ğ¾Ñ€ÑÑ‰Ğ¸Ğ¼Ğ¸ Ğ¸Ğ¼ĞµĞ½Ğ°Ğ¼Ğ¸
object PaymentConstants {
    val MIN_PAYMENT_AMOUNT = BigDecimal("10.00")
    val MAX_PAYMENT_AMOUNT = BigDecimal("10000.00")
    val PROCESSING_FEE_PERCENT = BigDecimal("0.03")
}

object PaymentGatewayStatus {
    const val SUCCESS = "SUCCESS"
    const val FAILED = "FAILED"
    const val PENDING = "PENDING"
}

// Ğ˜Ğ»Ğ¸ Enum (ĞµÑ‰Ñ‘ Ğ»ÑƒÑ‡ÑˆĞµ)
enum class PaymentGatewayStatus {
    SUCCESS,
    FAILED,
    PENDING
}

fun processPayment(amount: BigDecimal): PaymentResult {
    require(amount >= PaymentConstants.MIN_PAYMENT_AMOUNT) {
        "Amount must be at least ${PaymentConstants.MIN_PAYMENT_AMOUNT}"
    }
    require(amount <= PaymentConstants.MAX_PAYMENT_AMOUNT) {
        "Amount cannot exceed ${PaymentConstants.MAX_PAYMENT_AMOUNT}"
    }
    
    val fee = amount * PaymentConstants.PROCESSING_FEE_PERCENT
    val status = paymentGateway.charge(amount + fee)
    
    return when (status) {
        PaymentGatewayStatus.SUCCESS -> PaymentResult.Success
        PaymentGatewayStatus.FAILED -> PaymentResult.Failed
        PaymentGatewayStatus.PENDING -> PaymentResult.Pending
    }
}

// ĞšĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ Ñ‡ĞµÑ€ĞµĞ· properties
@ConfigurationProperties(prefix = "payment")
data class PaymentConfig(
    val minAmount: BigDecimal,
    val maxAmount: BigDecimal,
    val feePercent: BigDecimal
)

@Service
class PaymentService(private val config: PaymentConfig) {
    fun processPayment(amount: BigDecimal): PaymentResult {
        require(amount >= config.minAmount) {
            "Amount must be at least ${config.minAmount}"
        }
        // ...
    }
}
```

### ĞšĞ•Ğ™Ğ¡ #24 | Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ: Middle
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
**Ğ’ĞĞŸĞ ĞĞ¡:**
Ğ§Ñ‚Ğ¾ Ñ‚Ğ°ĞºĞ¾Ğµ Train Wreck (Ñ†ĞµĞ¿Ğ¾Ñ‡ĞºĞ° Ğ²Ñ‹Ğ·Ğ¾Ğ²Ğ¾Ğ²) Ğ¸ Law of Demeter? ĞŸĞ¾Ñ‡ĞµĞ¼Ñƒ ÑÑ‚Ğ¾ Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼Ğ°?

**ĞĞ¢Ğ’Ğ•Ğ¢:**
**Train Wreck**: Ğ´Ğ»Ğ¸Ğ½Ğ½Ñ‹Ğµ Ñ†ĞµĞ¿Ğ¾Ñ‡ĞºĞ¸ Ğ²Ñ‹Ğ·Ğ¾Ğ²Ğ¾Ğ² `a.getB().getC().getD().doSomething()`.
**Law of Demeter**: Ğ¾Ğ±ÑŠĞµĞºÑ‚ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ¾Ğ±Ñ‰Ğ°Ñ‚ÑŒÑÑ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ñ Ğ±Ğ»Ğ¸Ğ¶Ğ°Ğ¹ÑˆĞ¸Ğ¼Ğ¸ "Ğ´Ñ€ÑƒĞ·ÑŒÑĞ¼Ğ¸".

ĞŸÑ€Ğ¾Ğ±Ğ»ĞµĞ¼Ñ‹:
- Tight coupling: Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğµ B Ğ»Ğ¾Ğ¼Ğ°ĞµÑ‚ Ğ²ĞµÑÑŒ ĞºĞ¾Ğ´
- Ğ¡Ğ»Ğ¾Ğ¶Ğ½Ğ¾ Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ: Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ¼Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ²ÑÑ Ñ†ĞµĞ¿Ğ¾Ñ‡ĞºÑƒ
- ĞĞ°Ñ€ÑƒÑˆĞµĞ½Ğ¸Ğµ Ğ¸Ğ½ĞºĞ°Ğ¿ÑÑƒĞ»ÑÑ†Ğ¸Ğ¸

**ĞŸĞ Ğ˜ĞœĞ•Ğ  ĞšĞĞ”Ğ:**
```kotlin
// ĞŸĞ›ĞĞ¥Ğ: Train Wreck
fun processOrder(order: Order) {
    val street = order.getUser().getAddress().getStreet()
    
    if (order.getUser().getAddress().getCity() == "Moscow") {
        // Ğ”Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ° Ğ² ĞœĞ¾ÑĞºĞ²Ñƒ
    }
    
    val email = order.getUser().getContactInfo().getEmail()
    emailService.send(email, "Order confirmed")
}

// ĞŸÑ€Ğ¾Ğ±Ğ»ĞµĞ¼Ñ‹:
// 1. Ğ•ÑĞ»Ğ¸ Address == null â†’ NPE
// 2. Tight coupling: Order Ğ·Ğ½Ğ°ĞµÑ‚ Ğ¾ Ğ²Ğ½ÑƒÑ‚Ñ€ĞµĞ½Ğ½Ğ¾ÑÑ‚ÑÑ… User Ğ¸ Address
// 3. Ğ¡Ğ»Ğ¾Ğ¶Ğ½Ğ¾ Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ: Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ¼Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ User, Address, ContactInfo

// Ğ¥ĞĞ ĞĞ¨Ğ: Tell, Don't Ask + Ğ´ĞµĞ»ĞµĞ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ
class Order(
    private val user: User,
    val items: List<OrderItem>
) {
    // Ğ”ĞµĞ»ĞµĞ³Ğ¸Ñ€ÑƒĞµĞ¼ Ğ²Ğ¼ĞµÑÑ‚Ğ¾ "ÑĞ¿Ñ€Ğ°ÑˆĞ¸Ğ²Ğ°Ğ½Ğ¸Ñ"
    fun getDeliveryAddress(): String = user.getDeliveryAddress()
    
    fun isDeliveryToCity(city: String): Boolean = user.isInCity(city)
    
    fun sendConfirmationEmail(emailService: EmailService) {
        user.sendEmail(emailService, "Order confirmed")
    }
}

class User(
    private val address: Address,
    private val contactInfo: ContactInfo
) {
    fun getDeliveryAddress(): String = address.getFullAddress()
    
    fun isInCity(city: String): Boolean = address.city == city
    
    fun sendEmail(emailService: EmailService, subject: String) {
        emailService.send(contactInfo.email, subject)
    }
}

// Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ â€” Ğ±ĞµĞ· Train Wreck
fun processOrder(order: Order) {
    val address = order.getDeliveryAddress()
    
    if (order.isDeliveryToCity("Moscow")) {
        // Ğ”Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ° Ğ² ĞœĞ¾ÑĞºĞ²Ñƒ
    }
    
    order.sendConfirmationEmail(emailService)
}

// Ğ›ĞµĞ³ĞºĞ¾ Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ
@Test
fun `should send confirmation email`() {
    val mockUser = mockk<User>()
    val order = Order(mockUser, emptyList())
    
    every { mockUser.sendEmail(any(), any()) } just Runs
    
    order.sendConfirmationEmail(emailService)
    
    verify { mockUser.sendEmail(emailService, "Order confirmed") }
}
```

### ĞšĞ•Ğ™Ğ¡ #25 | Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ: Senior
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
**Ğ’ĞĞŸĞ ĞĞ¡:**
Ğ§Ñ‚Ğ¾ Ñ‚Ğ°ĞºĞ¾Ğµ Feature Envy? ĞšĞ°Ğº Ñ€Ğ°ÑĞ¿Ğ¾Ğ·Ğ½Ğ°Ñ‚ÑŒ Ğ¸ Ğ¸ÑĞ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ?

**ĞĞ¢Ğ’Ğ•Ğ¢:**
**Feature Envy**: Ğ¼ĞµÑ‚Ğ¾Ğ´ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ Ğ¸Ğ½Ñ‚ĞµÑ€ĞµÑÑƒĞµÑ‚ÑÑ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸ Ğ´Ñ€ÑƒĞ³Ğ¾Ğ³Ğ¾ ĞºĞ»Ğ°ÑÑĞ°, Ñ‡ĞµĞ¼ ÑĞ²Ğ¾ĞµĞ³Ğ¾.
ĞŸÑ€Ğ¸Ğ·Ğ½Ğ°Ğº: Ğ¼ĞµÑ‚Ğ¾Ğ´ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ Ğ¼Ğ½Ğ¾Ğ³Ğ¾ Ğ³ĞµÑ‚Ñ‚ĞµÑ€Ğ¾Ğ² Ğ´Ñ€ÑƒĞ³Ğ¾Ğ³Ğ¾ Ğ¾Ğ±ÑŠĞµĞºÑ‚Ğ°.

Ğ ĞµÑˆĞµĞ½Ğ¸Ğµ: Ğ¿ĞµÑ€ĞµĞ¼ĞµÑÑ‚Ğ¸Ñ‚ÑŒ Ğ¼ĞµÑ‚Ğ¾Ğ´ Ğ² ĞºĞ»Ğ°ÑÑ, Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ ĞºĞ¾Ñ‚Ğ¾Ñ€Ğ¾Ğ³Ğ¾ Ğ¾Ğ½ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚.

**ĞŸĞ Ğ˜ĞœĞ•Ğ  ĞšĞĞ”Ğ:**
```kotlin
// ĞŸĞ›ĞĞ¥Ğ: Feature Envy
class OrderReportGenerator {
    fun generateReport(order: Order): String {
        val total = order.items.sumOf { it.price * it.quantity.toBigDecimal() }
        val itemCount = order.items.size
        val avgPrice = if (itemCount > 0) total / itemCount.toBigDecimal() else BigDecimal.ZERO
        
        val discount = when {
            total > BigDecimal("1000") -> total * BigDecimal("0.1")
            total > BigDecimal("500") -> total * BigDecimal("0.05")
            else -> BigDecimal.ZERO
        }
        
        val finalTotal = total - discount
        
        return """
            Order Report
            Items: $itemCount
            Total: $total
            Discount: $discount
            Final: $finalTotal
        """.trimIndent()
    }
}
// ĞœĞµÑ‚Ğ¾Ğ´ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ Ğ¢ĞĞ›Ğ¬ĞšĞ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Order â€” Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ±Ñ‹Ñ‚ÑŒ Ğ² Order!

// Ğ¥ĞĞ ĞĞ¨Ğ: Ğ¼ĞµÑ‚Ğ¾Ğ´ Ğ² Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğ¼ ĞºĞ»Ğ°ÑÑĞµ
class Order(
    val id: Long,
    val items: List<OrderItem>
) {
    fun calculateTotal(): BigDecimal {
        return items.sumOf { it.price * it.quantity.toBigDecimal() }
    }
    
    fun calculateDiscount(): BigDecimal {
        val total = calculateTotal()
        return when {
            total > BigDecimal("1000") -> total * BigDecimal("0.1")
            total > BigDecimal("500") -> total * BigDecimal("0.05")
            else -> BigDecimal.ZERO
        }
    }
    
    fun getFinalTotal(): BigDecimal {
        return calculateTotal() - calculateDiscount()
    }
    
    fun generateReport(): String {
        val total = calculateTotal()
        val discount = calculateDiscount()
        val finalTotal = getFinalTotal()
        
        return """
            Order Report
            Items: ${items.size}
            Total: $total
            Discount: $discount
            Final: $finalTotal
        """.trimIndent()
    }
}

// Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€ÑƒĞµÑ‚
class OrderReportGenerator {
    fun generateReport(order: Order): String {
        return order.generateReport()  // ĞŸÑ€Ğ¾ÑÑ‚Ğ¾ Ğ´ĞµĞ»ĞµĞ³Ğ¸Ñ€ÑƒĞµÑ‚!
    }
}
```

---

## Ğ—Ğ°ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ

### ĞšĞ»ÑÑ‡ĞµĞ²Ñ‹Ğµ Ğ²Ñ‹Ğ²Ğ¾Ğ´Ñ‹

1. **SOLID Ğ¿Ñ€Ğ¸Ğ½Ñ†Ğ¸Ğ¿Ñ‹** â€” Ğ½Ğµ Ğ°Ğ±ÑÑ‚Ñ€Ğ°ĞºÑ†Ğ¸Ñ, Ğ° Ğ¿Ñ€Ğ°ĞºÑ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚Ñ‹:
   - SRP: Ğ¾Ğ´Ğ¸Ğ½ ĞºĞ»Ğ°ÑÑ = Ğ¾Ğ´Ğ½Ğ° Ğ¿Ñ€Ğ¸Ñ‡Ğ¸Ğ½Ğ° Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ
   - OCP: Strategy pattern Ğ²Ğ¼ĞµÑÑ‚Ğ¾ switch
   - LSP: ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ°Ñ Ğ¸ĞµÑ€Ğ°Ñ€Ñ…Ğ¸Ñ Ğ½Ğ°ÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
   - ISP: Ğ¼Ğ°Ğ»ĞµĞ½ÑŒĞºĞ¸Ğµ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹ÑÑ‹ Ğ»ÑƒÑ‡ÑˆĞµ Ğ±Ğ¾Ğ»ÑŒÑˆĞ¸Ñ…
   - DIP: Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ÑŒ Ğ¾Ñ‚ Ğ°Ğ±ÑÑ‚Ñ€Ğ°ĞºÑ†Ğ¸Ğ¹

2. **Clean Code** â€” Ğ¸Ğ½Ğ²ĞµÑÑ‚Ğ¸Ñ†Ğ¸Ñ Ğ² Ğ±ÑƒĞ´ÑƒÑ‰ĞµĞµ:
   - Ğ˜Ğ·Ğ±ĞµĞ³Ğ°Ğ¹Ñ‚Ğµ Ğ³Ğ»ÑƒĞ±Ğ¾ĞºĞ¾Ğ¹ Ğ²Ğ»Ğ¾Ğ¶ĞµĞ½Ğ½Ğ¾ÑÑ‚Ğ¸ (max 2-3 ÑƒÑ€Ğ¾Ğ²Ğ½Ñ)
   - ĞĞ³Ñ€Ğ°Ğ½Ğ¸Ñ‡Ğ¸Ğ²Ğ°Ğ¹Ñ‚Ğµ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ñ‹ Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ¾Ğ² (max 3-4)
   - Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ Ğ³Ğ¾Ğ²Ğ¾Ñ€ÑÑ‰Ğ¸Ğµ Ğ¸Ğ¼ĞµĞ½Ğ°
   - Ğ Ğ°Ğ·Ğ´ĞµĞ»ÑĞ¹Ñ‚Ğµ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹ Ğ¸ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑÑ‹

3. **ĞŸĞ°Ñ‚Ñ‚ĞµÑ€Ğ½Ñ‹** â€” Ñ€ĞµÑˆĞµĞ½Ğ¸Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞµĞ½Ğ½Ñ‹Ñ… Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼:
   - Chain of Responsibility Ğ´Ğ»Ñ Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ğ¸
   - Template Method Ğ´Ğ»Ñ Ğ¾Ğ±Ñ‰Ğ¸Ñ… Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼Ğ¾Ğ²
   - State Ğ´Ğ»Ñ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸ÑĞ¼Ğ¸
   - Strategy Ğ´Ğ»Ñ Ğ²Ğ·Ğ°Ğ¸Ğ¼Ğ¾Ğ·Ğ°Ğ¼ĞµĞ½ÑĞµĞ¼Ñ‹Ñ… Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼Ğ¾Ğ²

### ĞĞ° ÑĞ¾Ğ±ĞµÑĞµĞ´Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğ¸

**ĞĞµ Ğ³Ğ¾Ğ²Ğ¾Ñ€Ğ¸Ñ‚Ğµ**: Â«Ğ¯ Ğ·Ğ½Ğ°Ñ SOLID Ğ¿Ñ€Ğ¸Ğ½Ñ†Ğ¸Ğ¿Ñ‹Â»

**Ğ“Ğ¾Ğ²Ğ¾Ñ€Ğ¸Ñ‚Ğµ**: Â«Ğ’ Ğ¼Ğ¾ĞµĞ¼ Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğµ Ñ Ğ¿Ñ€Ğ¸Ğ¼ĞµĞ½Ğ¸Ğ» Strategy pattern Ğ´Ğ»Ñ payment gateway â€” ÑÑ‚Ğ¾ Ğ¿Ğ¾Ğ·Ğ²Ğ¾Ğ»Ğ¸Ğ»Ğ¾ 
Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ PayPal Ğ±ĞµĞ· Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰ĞµĞ³Ğ¾ ĞºĞ¾Ğ´Ğ°. Ğ Ğ°Ğ½ÑŒÑˆĞµ Ğ±Ñ‹Ğ» switch Ñ 5 case'Ğ°Ğ¼Ğ¸, Ñ‚ĞµĞ¿ĞµÑ€ÑŒ 
ĞºĞ°Ğ¶Ğ´Ñ‹Ğ¹ gateway â€” Ğ¾Ñ‚Ğ´ĞµĞ»ÑŒĞ½Ñ‹Ğ¹ ĞºĞ»Ğ°ÑÑ Ñ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹ÑĞ¾Ğ¼ PaymentStrategy. ĞŸĞ¾ĞºÑ€Ñ‹Ñ‚Ğ¸Ğµ Ñ‚ĞµÑÑ‚Ğ°Ğ¼Ğ¸ Ğ²Ñ‹Ñ€Ğ¾ÑĞ»Ğ¾ 
Ñ 60% Ğ´Ğ¾ 85%.Â»

**Ğ¦Ğ¸Ñ„Ñ€Ñ‹ > Ğ¡Ğ»Ğ¾Ğ²Ğ°. Ğ”ĞµĞ¼Ğ¾Ğ½ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ > Ğ¢ĞµĞ¾Ñ€Ğ¸Ñ.**

---

ğŸ“Š **ĞĞ¢Ğ§ĞĞ¢ Ğ Ğ’Ğ«ĞŸĞĞ›ĞĞ•ĞĞ˜Ğ˜:**
- **ĞœĞ¾Ğ´ĞµĞ»ÑŒ**: Claude Sonnet 4.5 (Auto mode)
- **ĞšĞµĞ¹ÑĞ¾Ğ² ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¾**: 25 Ğ´ĞµÑ‚Ğ°Ğ»ÑŒĞ½Ñ‹Ñ… ĞºĞµĞ¹ÑĞ¾Ğ²
- **Ğ¡Ñ‚Ñ€Ğ¾Ğº ĞºĞ¾Ğ´Ğ°**: ~3500
- **ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ğ½Ğ¾Ğµ Ğ²Ñ€ĞµĞ¼Ñ Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸**: 5-6 Ğ¼Ğ¸Ğ½ÑƒÑ‚
- **ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ğ½Ğ°Ñ ÑÑ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ**: ~$3.00-3.50

---

*Ğ”Ğ°Ñ‚Ğ° ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ: Ğ¯Ğ½Ğ²Ğ°Ñ€ÑŒ 2026 | Ğ’ĞµÑ€ÑĞ¸Ñ: 1.0*

