spring:
  application:
    name: hh-assistant
  output:
    ansi:
      enabled: always

  datasource:
    url: ${SPRING_DATASOURCE_URL:jdbc:postgresql://localhost:5432/hh_assistant}
    username: ${SPRING_DATASOURCE_USERNAME:hh_user}
    password: ${SPRING_DATASOURCE_PASSWORD:hh_pass}
    driver-class-name: org.postgresql.Driver

  liquibase:
    change-log: classpath:db/changelog/db.changelog-master.yaml
    enabled: true

  jpa:
    hibernate:
      ddl-auto: validate
    show-sql: false
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
        format_sql: true
        # Batch-операции для оптимизации сохранения вакансий
        jdbc:
          batch_size: 50  # Размер батча для Hibernate (группирует INSERT-запросы)
          batch_versioned_data: true  # Включает batch для версионированных данных
        order_inserts: true  # Упорядочивает INSERT для лучшей производительности
        order_updates: true  # Упорядочивает UPDATE для лучшей производительности

  jackson:
    serialization:
      write-dates-as-timestamps: false
    default-property-inclusion: non_null

app:
  api:
    base-url: ${APP_API_BASE_URL:http://localhost:8080}  # Base URL для API endpoints (для кнопок в Telegram)
  schedule:
    vacancy-check: "0 */10 * * * *"  # Every 10 minutes
    skipped-retry: "0 */5 * * * *"  # Every 5 minutes - retry skipped vacancies when Circuit Breaker recovers
    extract-relevant-skills: "0 0 3 * * *"  # Every day at 3:00 AM - extract skills for relevant vacancies without skills
    process-queued-vacancies: "0 */10 * * * *"  # Every 10 minutes - process QUEUED vacancies from database
    recovery-skill-extraction: "0 */5 * * * *"  # Every 5 minutes - recovery: extract skills from one vacancy if processing queue is empty
    healthcheck:
    enabled: true  # Включить периодическую проверку здоровья системы
    schedule: "0 0 * * * *"  # Каждый час (cron: секунда минута час день месяц день_недели)
    max-vacancies-per-cycle: 2000  # Максимальное количество вакансий за цикл (ограничение HH.ru API: 2000)
  cleanup:
    enabled: true  # Включить автоматическую очистку несуществующих вакансий
    schedule: "0 0 2 * * *"  # Каждый день в 2:00 (cron: секунда минута час день месяц день_недели)
    batch-size: 50  # Количество вакансий для проверки за один батч
  vacancy-recovery:
    batch-size: 100  # Количество вакансий для обработки за один батч
    retry-window-hours: 48  # Окно времени для retry в часах (вакансии старше этого времени считаются старыми)
    process-old-vacancies: true  # Обрабатывать старые вакансии (вне окна времени): восстановление/терминальный статус/удаление
  # Для работы с реальными вакансиями:
  # 1. Убедитесь, что HH_ACCESS_TOKEN указан в .env
  # 2. Настройте поиск через БД (см. docs/WINDOWS_SETUP.md) ИЛИ через application.yml (см. ниже)
  search:
    # rotation-strategy: all (default) | rotation
    # - all: все ключевые слова keywords-rotation за один цикл
    # - rotation: одно ключевое слово за цикл (round-robin по keywords-rotation)
    # rotation-strategy: all
    # Альтернативный способ настройки поиска через application.yml
    # Если указаны keywords, они будут использованы вместо конфигураций из БД
    # keywords: ${APP_SEARCH_KEYWORDS:}  # Например: "Kotlin Developer" (одно ключевое слово)
    # keywords-rotation: ["Java", "Kotlin"]  # Массив для ротации - каждый цикл будет использоваться следующее ключевое слово
    keywords-rotation:
      - "Java"
      - "Kotlin"
    # area: ${APP_SEARCH_AREA:}  # Например: "Москва"
    # min-salary: ${APP_SEARCH_MIN_SALARY:}  # Например: 150000
    # experience: ${APP_SEARCH_EXPERIENCE:}  # Например: "От 3 лет"
    # Список ID опыта работы для фильтрации вакансий
    # Доступные значения: "noExperience", "between1And3", "between3And6", "moreThan6"
    experience-ids:
      - "between1And3"  # От 1 года до 3 лет
      - "between3And6"  # От 3 до 6 лет
  vacancy-processing:
    queue:
      enabled: true  # Enable/disable vacancy processing queue (high priority - analysis)
      max-concurrent: 1  # Maximum concurrent vacancy analysis operations (limited to 1 for weak LLM models)
      batch-size: 10  # Number of vacancies to process per batch
  skill-extraction:
    queue:
      enabled: true  # Enable/disable skill extraction queue (low priority)
      max-concurrent: 1  # Maximum concurrent skill extraction operations (limited to 1 for weak LLM models)
  analysis:
    min-relevance-score: 0.6  # Minimum score to consider vacancy relevant
    max-concurrent-requests: 1  # Maximum concurrent requests to LLM for analysis (limited to 1 for weak LLM models)
    max-concurrent-url-checks: 2  # Maximum concurrent URL validation checks to HH.ru API (works with rate limiting)
    # Ключевые слова и фразы, при наличии которых вакансия автоматически отклоняется (до анализа LLM)
    exclusion-keywords:  # Список запрещенных слов (проверяется в названии, описании, работодателе)
      - "стажер"
      - "Стажер"
      - "intern"
      - "стажировка"
      - "без опыта"
      - "junior"
      - "джуниор"
      - "trainee"
      - "Lead"
      - "QA"
      - "Android"
      - "Fullstack"
      - "без опыта работы"
      - "опыт не требуется"
      - "для начинающих"
      - "для студентов"
      - "стажировка"
      - "internship"
    exclusion-case-sensitive: false  # Учитывать регистр при поиске (false = регистронезависимый поиск)
    skill-matching:
      enabled: true  # Включить предварительную проверку навыков из резюме (пропуск LLM если нет совпадений)
  log-analysis:
    enabled: true  # Enable daily log analysis with Ollama
    cron: "0 0 9 * * *"  # Cron expression for daily analysis (every day at 9:00 AM)
    log-file: logs/hh-assistant.log  # Path to log file
    lookback-hours: 24  # Number of hours to look back when analyzing logs
    batch-size: 500  # Number of log lines per batch for analysis
    max-batches: 10  # Maximum number of batches to process (to avoid too long analysis)
    summary-first: true  # First create summaries of batches, then analyze summaries
  ollama-monitoring:
    enabled: true  # Enable Ollama status monitoring
    interval-seconds: 5  # Interval between status checks (in seconds)
    recovery:
      enabled: true  # Enable recovery of failed/skipped vacancies when idle
      interval-seconds: 10  # Interval between recovery attempts (in seconds)
      pause-when-empty-minutes: 30  # Pause recovery when no vacancies to recover (in minutes)
    skipped-validation:
      enabled: true  # Enable parallel validation of skipped vacancies while LLM is processing
      batch-size: 20  # Number of skipped vacancies to process per batch
      interval-seconds: 5  # Interval between validation batches (in seconds)
  prompts:
    # Системный промпт для анализа вакансий (максимально оптимизирован для скорости)
    # Требует только skills и relevance_score - без reasoning для ускорения
    analysis-system: |
      Извлеки навыки из вакансии и определи процент совпадения с резюме.

      КРИТИЧЕСКИ ВАЖНЫЕ ПРАВИЛА (проверяй в таком порядке):
      1. СНАЧАЛА проверь опыт: если требуемый опыт больше 3 лет (например: "от 4 лет", "4+ лет", "5 лет", "свыше 3", "от 3 до 5" где минимум больше 3) - вакансия НЕ ПОДХОДИТ (relevance_score = 0.0). ОСТАНОВИСЬ, дальше не проверяй.
      2. Если опыт 3 года или меньше (например: "до 3 лет", "1-3 года", "от 1 до 3 лет", "3 года", "не требуется", "без опыта") И в вакансии есть фразы Java, Kotlin, Spring, Boot (в любом регистре) - вакансия ПОДХОДИТ (relevance_score = 1.0).
      3. В остальных случаях считай по обычным правилам (навыки 40%, опыт 30%, позиция 20%, зарплата 10%).

      JSON:
      {
          "skills": ["Kotlin", "Spring Boot", "PostgreSQL"],
          "relevance_score": 0.85
      }

      skills: технологии из вакансии (3-20). relevance_score: 0.0-1.0 (навыки 40%, опыт 30%, позиция 20%, зарплата 10%).
      Только JSON.
    # Шаблон промпта для анализа (максимально оптимизирован - компактный формат)
    # Переменные: {vacancyName}, {salary}, {experience}, {description}, {resumeContent}
    analysis-template: |
      {vacancyName} | {salary} | {experience}

      {description}

      Резюме: {resumeContent}

      Извлеки навыки и определи совпадение. JSON: {"skills": [...], "relevance_score": 0.0-1.0}
    # Системный промпт для генерации сопроводительного письма
    cover-letter-system: |
      Ты - эксперт по написанию сопроводительных писем. Напиши КРАТКОЕ, ЕСТЕСТВЕННОЕ и ПЕРСОНАЛИЗИРОВАННОЕ сопроводительное письмо (максимум 120 слов, идеально 80-100 слов).

      КРИТИЧЕСКИ ВАЖНО - ЯЗЫК:
      - Письмо должно быть написано ТОЛЬКО на русском или английском языке
      - ЗАПРЕЩЕНО использовать китайский язык (中文), японский язык (日本語), корейский язык (한국어) или ЛЮБЫЕ другие языки
      - Если описание вакансии на английском - используй английский
      - Во всех остальных случаях используй ТОЛЬКО русский язык
      - Если ты напишешь хотя бы одно слово на китайском, японском или другом языке - это КРИТИЧЕСКАЯ ОШИБКА

      СТИЛЬ ПИСЬМА:
      - Естественный, человечный тон (не шаблонный, не роботизированный)
      - Краткость и конкретность (без воды и общих фраз)
      - Покажи реальный интерес к позиции, а не формальную вежливость
      - Используй простые, понятные предложения
      - Избегай канцеляризмов и штампов типа "высококвалифицированный специалист"

      СТРУКТУРА (примерно):
      1. Краткое обращение (1 предложение)
      2. Почему именно эта вакансия интересна (2-3 предложения)
      3. Что ты можешь предложить (2-3 предложения)
      4. Краткое завершение (1 предложение)

      ПРИМЕР ХОРОШЕГО ПИСЬМА (на русском):
      "Здравствуйте! Меня заинтересовала вакансия Java-разработчика в вашей компании.
      У меня 3 года опыта работы с Spring Boot и PostgreSQL, что полностью соответствует вашим требованиям.
      Особенно интересен ваш проект с микросервисной архитектурой - у меня есть опыт работы с подобными системами.
      Буду рад обсудить детали!"

      НЕ ДЕЛАЙ:
      - Длинные абзацы
      - Повторение информации из резюме
      - Общие фразы без конкретики
      - Шаблонные выражения
      - Использование языков кроме русского/английского
    # Шаблон промпта для генерации сопроводительного письма (переменные: {vacancyName}, {employer}, {description}, {matchedSkills}, {summary})
    cover-letter-template: |
      Напиши КРАТКОЕ (80-120 слов), ЕСТЕСТВЕННОЕ и ПЕРСОНАЛИЗИРОВАННОЕ сопроводительное письмо для следующей вакансии:

      Вакансия: {vacancyName}
      Работодатель: {employer}
      Описание: {description}

      Релевантные навыки кандидата: {matchedSkills}
      {summary}

      КРИТИЧЕСКИ ВАЖНО:
      1. ЯЗЫК: ТОЛЬКО русский или английский. ЗАПРЕЩЕНО использовать китайский (中文), японский (日本語), корейский (한국어) или любые другие языки.
      2. ДЛИНА: Максимум 120 слов, идеально 80-100 слов. Будь кратким и конкретным.
      3. СТИЛЬ: Естественный, человечный тон. Избегай шаблонов и канцеляризмов.
      4. СОДЕРЖАНИЕ: Покажи реальный интерес к позиции, упомяни конкретные навыки из списка выше, объясни почему именно эта вакансия интересна.

      Если описание вакансии на английском - используй английский. Во всех остальных случаях - ТОЛЬКО русский язык.

      Начни писать письмо прямо сейчас, без дополнительных комментариев.
    # Системный промпт для проверки города вакансии
    city-validation-system: |
      Ты - эксперт по географии. Твоя задача - определить, является ли указанный город российским.

      Верни результат в формате JSON:
      {
          "is_russian_city": true,
          "city": "Москва"
      }

      Требования:
      - is_russian_city: true если город находится в России, false если в другой стране
      - city: нормализованное название города (если указан регион, верни только город)
      - Учитывай, что города могут быть указаны как "Москва", "Москва, Россия", "Moscow, Russia" и т.д.
      - Российские города: Москва, Санкт-Петербург, Новосибирск, Екатеринбург, Казань, Нижний Новгород, Челябинск и т.д.
      - НЕ российские: Киев, Минск, Алматы, Ташкент, Вильнюс, Рига, Таллин и т.д.
      - Отвечай ТОЛЬКО валидным JSON, без дополнительных комментариев
    # Шаблон промпта для проверки города вакансии
    # Переменные: {area}
    city-validation-template: |
      Определи, является ли следующий город российским:

      Город: {area}

      Верни результат в формате JSON: {"is_russian_city": true/false, "city": "название города"}

ollama:
  base-url: ${OLLAMA_BASE_URL:http://localhost:11434}  # Автоматически определяется: localhost для локального запуска, host.docker.internal для Docker
  model: ${OLLAMA_MODEL:qwen2.5:7b}
  temperature: 0.7  # Default temperature (для обратной совместимости)
  # Оптимизированные temperature для анализа вакансий
  analysis:
    temperature: 0.3  # Низкая temperature для детерминированного анализа
  rate-limit:
    requests-per-second: 2  # Ограничение запросов к LLM (защита от перегрузки)
    burst-capacity: 4
    wait-on-limit-seconds: 1
  timeout-seconds: 90  # Таймаут для HTTP запросов к Ollama (responseTimeout и ReadTimeoutHandler)
  max-in-memory-size-mb: 10
  # Таймауты на уровне корутин для разных типов задач (защита от "задумавшихся" запросов)
  timeouts:
    vacancy-analysis: 120  # Таймаут для анализа вакансий (секунды) - может быть дольше из-за сложности
    skill-extraction: 120   # Таймаут для извлечения навыков (секунды)
    log-analysis: 180      # Таймаут для анализа логов (секунды) - может быть очень долгим из-за больших объемов
    other: 90              # Таймаут для других задач (секунды)

telegram:
  api:
    base-url: https://api.telegram.org
  rate-limit:
    requests-per-second: 10  # Telegram: ~30 msg/sec limit, используем 10 для безопасности
    burst-capacity: 20
    wait-on-limit-seconds: 1
  bot-token: ${TELEGRAM_BOT_TOKEN:}
  chat-id: ${TELEGRAM_CHAT_ID:}
  enabled: ${TELEGRAM_ENABLED:true}
  content-type: application/json
  # Использовать веб-скрапинг для публичных каналов (не требует прав администратора)
  use-web-scraping: ${TELEGRAM_USE_WEB_SCRAPING:true}
  # Авторизация пользователей - только разрешенные пользователи могут использовать команды
  authorization:
    enabled: ${TELEGRAM_AUTHORIZATION_ENABLED:true}  # Включить проверку авторизации
    # Разрешенные пользователи (можно указать по user ID или username)
    # Формат: список user ID (числа) или username (строки с @)
    # Пример: allowed-users: [123456789, "@myusername"]
    # Если список пуст и authorization.enabled=true, доступ будет запрещен всем
    allowed-user-ids: ${TELEGRAM_ALLOWED_USER_IDS:1126891709}  # Список разрешенных user ID через запятую (например: 123456789,987654321)
    allowed-usernames: ${TELEGRAM_ALLOWED_USERNAMES:}  # Список разрешенных username через запятую (например: @myusername,@anotheruser)
  polling:
    enabled: ${TELEGRAM_POLLING_ENABLED:true}  # Включить polling для получения команд от пользователей
    interval-seconds: ${TELEGRAM_POLLING_INTERVAL:5}  # Интервал между запросами getUpdates (в секундах)
    timeout-seconds: ${TELEGRAM_POLLING_TIMEOUT:30}  # Таймаут для long polling (в секундах, 0-60)
  # Настройки веб-скрапинга для публичных Telegram каналов
  web-scraping:
    enabled: ${TELEGRAM_WEB_SCRAPING_ENABLED:true}  # Включить веб-скрапинг
    user-agent: ${TELEGRAM_WEB_SCRAPING_USER_AGENT:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36}  # User-Agent для запросов
    timeout: ${TELEGRAM_WEB_SCRAPING_TIMEOUT:10000}  # Таймаут запросов в миллисекундах

hh:
  api:
    base-url: https://api.hh.ru
    access-token: ${HH_ACCESS_TOKEN:}
    # Тип токена: "user" (OAuth токен пользователя) или "application" (токен приложения)
    # Токен приложения имеет неограниченный срок жизни и используется для публичного API
    token-type: ${HH_TOKEN_TYPE:user}  # user или application
    # Формат HH-User-Agent для HH.ru API: "AppName/Version (contact@email.com)"
    # ВАЖНО: HH-User-Agent является обязательным заголовком (required) для всех запросов к HH.ru API
    # Если не указан, будет использован минимальный формат: "HH-Assistant/1.0"
    # Для production рекомендуется указать реальный email: "HH-Assistant/1.0 (your@email.com)"
    user-agent: ${HH_USER_AGENT:}
    accept-header: application/json
    auth-prefix: Bearer
    max-in-memory-size-mb: 10  # Максимальный размер буфера для ответов API (в МБ, по умолчанию 256KB)
    search:
      per-page: 100  # Количество вакансий на страницу (максимум согласно документации HH.ru API)
      default-page: 0
      always-start-from-zero: true  # Всегда начинать с первой страницы при каждом фетче (true = перебирать все вакансии заново, false = использовать сохраненный прогресс)
    pagination:
      restart-cooldown-hours: 1  # Cooldown между перезапусками пагинации (в часах) для предотвращения бесконечных циклов
  oauth:
    client-id: ${HH_CLIENT_ID:}
    client-secret: ${HH_CLIENT_SECRET:}
    redirect-uri: ${HH_REDIRECT_URI:http://localhost:8080/oauth/callback}
    authorization-url: https://hh.ru/oauth/authorize
    token-url: https://hh.ru/oauth/token
    # Scope для доступа к API вакансий
    # По умолчанию HH.ru предоставляет базовые права, но для некоторых операций могут потребоваться дополнительные scope
    scope: ${HH_OAUTH_SCOPE:}
  proxy:
    enabled: ${PROXY_ENABLED:false}
    host: ${PROXY_HOST:}
    port: ${PROXY_PORT:8080}
    type: ${PROXY_TYPE:HTTP}
    timeout-seconds: 30
  retry:
    max-attempts: 3
    initial-delay-seconds: 2
    max-backoff-seconds: 10
    rate-limit-status-code: 429
  rate-limit:
    requests-per-second: 2  # Лимит запросов в секунду (2 запроса в секунду для HH.ru API)
    burst-capacity: 4  # Максимальное количество одновременных запросов (позволяет сделать несколько запросов подряд)
    wait-on-limit-seconds: 1  # Время ожидания при превышении лимита (в секундах)
  currency:
    default: RUR
  vacancy:
    area-not-specified: "Не указан"

logging:
  level:
    root: INFO
    com.hhassistant: DEBUG
    org.springframework.web: INFO
    org.hibernate: WARN
  pattern:
    # Добавляем traceId и vacancyId в паттерн логов для трассировки
    console: "%d{yyyy-MM-dd HH:mm:ss} [%X{traceId:-}] [%X{vacancyId:-}] - %msg%n"
    file: "%d{yyyy-MM-dd HH:mm:ss} [%thread] [%X{traceId:-}] [%X{vacancyId:-}] %-5level %logger{36} - %msg%n"
  file:
    name: logs/hh-assistant.log

management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
  endpoint:
    health:
      show-details: when-authorized
      show-components: always
    metrics:
      enabled: true
    prometheus:
      enabled: true
  metrics:
    export:
      prometheus:
        enabled: true
    tags:
      application: ${spring.application.name}
  health:
    indicators:
      enabled: true
    ollama:
      enabled: true
    hhapi:
      enabled: true
    telegram:
      enabled: true

# Resilience4j configuration for Circuit Breaker and Retry
resilience:
  circuit-breaker:
    failure-rate-threshold: 50  # Percentage of failures that will open the circuit
    wait-duration-in-open-state-seconds: 60  # Time to wait before attempting to close the circuit
    sliding-window-size: 10  # Number of calls to track in the sliding window
    minimum-number-of-calls: 5  # Minimum number of calls before calculating failure rate
  retry:
    max-attempts: 3  # Maximum number of retry attempts
    wait-duration-millis: 1000  # Wait duration between retries (in milliseconds)
    # Retry configuration for rate limit (429) errors - exponential backoff
    rate-limit-retry:
      max-attempts: 5  # Maximum number of retry attempts for rate limit errors
      initial-wait-millis: 2000  # Initial wait before first retry (2 seconds)
      backoff-multiplier: 2.0  # Exponential backoff multiplier (2s -> 4s -> 8s -> 16s)
